* Cover
:PROPERTIES:
:UNNUMBERED: t
:END:
"In the Wild" realworld code examples

Aside, Official docs:-
[[file:cheatsheet-usletter-color.pdf]]
[[file:clojure-api-docs/api-index.html]]
* Part I ---------------------------------------------------------------------------------------------------
:PROPERTIES:
:UNNUMBERED: t
:END:


* Hello, Clojure
** The Very Basics
#+begin_src clojure
(println "Hello, World")
;; => nil
(str "Clo" "jure")
;; => "Clojure"
(str "Hi" 007)
;; => "Hi7"
(count "Anoop")
;; => 5
(println true)
;; => nil
(println false)
;; => nil
#+end_src

** Arithmetic
#+begin_src clojure
(+ 1900 84)
;; => 1984
(* 3.14 3.14)
;; => 9.8596
#+end_src

*prefix* notation
~(<verb> arg1 arg2 ...)~
** def
#+begin_src clojure
(def first-name "Russ")
;; => #'user/first-name
#+end_src
binds a symbol with a value

*all-lower-case-with-words-seperated-by-dashes* convention, aka kebab-case
** A Function of Your Own
#+begin_src clojure
(defn hello-world [] (println "Hello, world!"))
;; => #'user/hello-world
(hello-world)
;; => nil
#+end_src

#+begin_src clojure
(defn hello-someone [name]
  (println "Hello" name))
;; => #'user/hello-someone
(hello-someone "Anoop")
;; => nil

(defn average [a b]
  (/ (+ a b) 2.0))
;; => #'user/average
(average 5 10)
;; => 7.5
#+end_src
** In the Wild
Created a ~lein~ project called /blottsbooks/ and ran it.

~:gen-class~ means compile this namespace

you need to define a function before you can use it
therefore, clojure codebases tend to read bottom up
** Staying out of trouble
#+begin_src clojure
(/ 100 0)
;; => Execution error (ArithmeticException) at user/eval10074 (REPL:70).
;;    Divide by zero
(bla 2 3)
;; => Syntax error compiling at (readme.org:73:1).
;;    Unable to resolve symbol: bla in this context
#+end_src

functions are values
#+begin_src clojure
hello-world
;; => #function[user/hello-world]
#+end_src
* Vectors and Lists
** One thing after another
#+begin_src clojure
[1 2 3 4]
;; => [1 2 3 4]
[1 true "three"]
;; => [1 true "three"]
[1 ["hi" "there" 2] 3 println]
;; => [1 ["hi" "there" 2] 3 #function[clojure.core/println]]
#+end_src
** A toolkit of functions for vectors
#+begin_src clojure
(vector 1 2 3)
;; => [1 2 3]
(vector)
;; => []
(def novels ["Emma" "Coma" "War and Peace"])
;; => #'user/novels
(count novels)
;; => 3
(first novels)
;; => "Emma"
(rest novels)
;; => ("Coma" "War and Peace")
#+end_src
~rest~ always returns a /sequence/

#+begin_src clojure
(def year-books ["1491" "April 1865" "1984" "2001"])
;; => #'user/year-books
(def third-book (first (rest (rest year-books))))
;; => #'user/third-book
third-book
;; => "1984"

(nth year-books 2)                      ;zero based index
;; => "1984"
(year-books 2)
;; => "1984"
#+end_src
** Growing your vectors
conj = conjunction
cons = construct
#+begin_src clojure
novels
;; => ["Emma" "Coma" "War and Peace"]
(conj novels "Carrie")
;; => ["Emma" "Coma" "War and Peace" "Carrie"]
(cons "Carrie" novels)
;; => ("Carrie" "Emma" "Coma" "War and Peace")
#+end_src
** Lists
#+begin_src clojure
'(1 2 3)
;; => (1 2 3)
'()
;; => ()
()
;; => ()
#+end_src
Lists are different from sequences. See Chapter 10.

#+begin_src clojure
'(1 "two" 3 4.0 [5 "five"])
;; => (1 "two" 3 4.0 [5 "five"])
(list 1 2 3)
;; => (1 2 3)
(def poems '("Illiad" "Odyssey" "Now we are six"))
;; => #'user/poems
(count poems)
;; => 3
(first poems)
;; => "Illiad"
(rest poems)
;; => ("Odyssey" "Now we are six")
(nth poems 2)
;; => "Now we are six"
#+end_src
** Lists vs Vectors
Vectors behave like arrays.   (But unlike arrays their representation is optimised for easy copy creation to satisfy clojure immutability.)
Lists are linked list of cons cells

[[xournalpp:lists-vs-vectors.xopp][lists-vs-vectors]]

conj does things keeping efficiency in mind
#+begin_src clojure
poems
;; => ("Illiad" "Odyssey" "Now we are six")
(conj poems "Jabberwocky")
;; => ("Jabberwocky" "Illiad" "Odyssey" "Now we are six")
(def vector-poems ["Illiad" "Odyssey" "Now we are six"])
;; => #'user/vector-poems
(conj vector-poems "Jabberwocky")
;; => ["Illiad" "Odyssey" "Now we are six" "Jabberwocky"]
#+end_src
in general, prefer to use vectors over lists
** Staying out of trouble
immutability
#+begin_src clojure
(def novels ["Emma" "Coma" "War and Peace"])
;; => #'user/novels
(conj novels "Jaws")
;; => ["Emma" "Coma" "War and Peace" "Jaws"]
novels
;; => ["Emma" "Coma" "War and Peace"]
(def more-novels (conj novels "Jaws"))
;; => #'user/more-novels
#+end_src
** In the Wild
clostache
pedestal/samples
* Maps, Keywords and Sets
** This Goes with That
map
#+begin_src clojure
{"title" "Oliver Twist" "author" "Dickens" "published" 1838}
;; => {"title" "Oliver Twist", "author" "Dickens", "published" 1838}

(hash-map "title" "Oliver Twist" "author" "Dickens" "published" 1838)
;; => {"author" "Dickens", "published" 1838, "title" "Oliver Twist"}

(def book {"title" "Oliver Twist" "author" "Dickens" "published" 1838})
;; => #'user/book
(get book "published")
;; => 1838
(book "published")
;; => 1838
#+end_src
** Keywords
#+begin_src clojure
(def book
  {:title "Oliver Twist" :author "Dickens" :published 1838})
;; => #'user/book
(:title book)
;; => "Oliver Twist"
#+end_src
** Changing your Map without changing it
#+begin_src clojure
book
;; => {:title "Oliver Twist", :author "Dickens", :published 1838}
(assoc book :page-count 362)
;; => {:title "Oliver Twist",
;;     :author "Dickens",
;;     :published 1838,
;;     :page-count 362}
book
;; => {:title "Oliver Twist", :author "Dickens", :published 1838}
(assoc book :page-count 362 :language "English")
;; => {:title "Oliver Twist",
;;     :author "Dickens",
;;     :published 1838,
;;     :page-count 362,
;;     :language "English"}
(dissoc book :page-count)
;; => {:title "Oliver Twist", :author "Dickens", :published 1838}
#+end_src

Vectors can be looked at as maps of keys as 0, 1, 2 ... to respective indexed items of that vector.
Therefore, assoc and dissoc also work on vectors
#+begin_src clojure
(def num0 ["zero" "one" "two" "three"])
;; => #'user/num0
(assoc num0 4 "four")
;; => ["zero" "one" "two" "three" "four"]
(dissoc num0 0)
;; => Execution error (ClassCastException) at user/eval10398 (REPL:54).
;;    class clojure.lang.PersistentVector cannot be cast to class clojure.lang.IPersistentMap (clojure.lang.PersistentVector and clojure.lang.IPersistentMap are in unnamed module of loader 'app')
#+end_src
^Doubt: Why isnt ~dissoc~ working on vectors?

#+begin_src clojure
book
;; => {:title "Oliver Twist", :author "Dickens", :published 1838}
(keys book)
;; => (:title :author :published)
(vals book)
;; => ("Oliver Twist" "Dickens" 1838)
#+end_src
** Sets
#+begin_src clojure
(def genres #{:sci-fi :romance :mystery})
;; => #'user/genres
(def authors #{"Dickens" "Austen" "King"})
;; => #'user/authors
(def repeats-not-allowed #{"Dickens" "King" "Dickens"})
;; => Syntax error reading source at (REPL:74:55).
;;    Duplicate key: Dickens
#+end_src

Membership
#+begin_src clojure
(contains? authors "Austen")
;; => true
(contains? genres :bla)
;; => false

(authors "Austen")
;; => "Austen"
(genres :animated)
;; => nil

(:sci-fi genres)
;; => :sci-fi
(:animated genres)
;; => nil

(def more-authors (conj authors "Clarke"))
;; => #'user/more-authors
more-authors
;; => #{"King" "Dickens" "Clarke" "Austen"}
(conj more-authors "Clarke")
;; => #{"King" "Dickens" "Clarke" "Austen"}
(disj more-authors "King")
;; => #{"Dickens" "Clarke" "Austen"}
#+end_src
** In the wild
The configuration accepted by clojure.java.jdbc is a map
The results of db queries are maps

In general, clojure softwares are typically:- maps go in -> maps come out

#+begin_src clojure
(require 'clojure.java.jdbc)
;; => Execution error (FileNotFoundException) at user/eval10431 (REPL:112).
;;    Could not locate clojure/java/jdbc__init.class, clojure/java/jdbc.clj or clojure/java/jdbc.cljc on classpath.
#+end_src

Membership test using literal set
#+begin_src clojure
(def city "Bombay")
;; => #'user/city
(#{"Bombay" "Kharagpur" "Madras" "Delhi" "Roorkie" "Guwahati"} city)
;; => "Bombay"

(def subprotocol "sqlite")
;; => #'user/subprotocol
(#{"derby" "h2" "hsqldb" "sqlite"} subprotocol)
;; => "sqlite"
#+end_src

boot-clj/boot
** Staying out of trouble
tldr: be careful when a map element's value can be ~nil~. Also, when some set element can be ~nil~

#+begin_src clojure
(def anonymous-book {:title "The Arabian Nights" :author nil})
;; => #'user/anonymous-book
(:author anonymous-book)                
;; => nil
;;although above returns nil, it doesnt imply that :author key is absent
(contains? anonymous-book :author)
;; => true
#+end_src
similar pitfall for sets. Be cautious when the set might contain ~nil~
#+begin_src clojure
(def possible-authors #{"Austen" "Dickens" nil})
;; => #'user/possible-authors
(possible-authors nil)
;; => nil
;;although above returns nil, it doesnt mean that my set doesnt contain nil
(contains? possible-authors nil)
;; => true
#+end_src

maps viewed as collection of two element vectors
#+begin_src clojure
book
;; => {:title "Oliver Twist", :author "Dickens", :published 1838}
(first book)
;; => [:title "Oliver Twist"]
(rest book)
;; => ([:author "Dickens"] [:published 1838])
(count book)
;; => 3
#+end_src
* Logic
** The Fundamental if
#+begin_src clojure
(defn print-greeting [preferred-customer]
  (if preferred-customer
    (println "Welcome back to Blotts Books!")))
;; => #'user/print-greeting
(print-greeting true)
;; => nil
#+end_src

else
#+begin_src clojure
(defn print-greeting [preferred-customer]
  (if preferred-customer
    (println "Welcome back to Blotts Books!")
    (println "Welcome to Blotts Books")))
;; => #'user/print-greeting
(defn shipping-charge [preferred-customer order-amount]
  (if preferred-customer
    0
    (* order-amount 0.10)))
;; => #'user/shipping-charge

#+end_src
** Asking Questions
#+begin_src clojure
(= 1 1)
;; => true
(= 2 (+ 1 1))
;; => true
(= "Anna Karenina" "Jane Eyre")
;; => false
(= "Emma" "Emma")
;; => true
(= (+ 2 2) 4 (/ 40 10) (* 2 2) (- 5 1))
;; => true
(= 2 3 2)
;; => false
#+end_src

#+begin_src clojure
(not= "Anna Karenina" "Jane Eyre")
;; => true
(not= "Anna Karenina" "Anna Karenina")
;; => false
#+end_src
lly ~<~ , ~>~, ~<=~, ~>=~

builtin type predicates
#+begin_src clojure
(number? 1984)
;; => true
(number? "Anna Karenina")
;; => false
(string? "Anna Karenina")
;; => true
(keyword? "Anna Karenina")
;; => false
(keyword? :anna-karenina)
;; => true
(map? :anna-karenina)
;; => false
(map? {:title 1984})
;; => true
(vector? 1984)
;; => false
(vector? [1984])
;; => true
#+end_src

~not~, ~or~, ~and~
#+begin_src clojure
(defn shipping-surcharge? [preferred-customer express oversized]
  (and (not preferred-customer) (or express oversized)))
;; => #'user/shipping-surcharge?
#+end_src
** Truthy and Falsy
Only =false= and =nil= are falsy
everything else is truthy
** Do and When
~do~ is clojure's version of ~progn~ from elisp
~when~ =  ~if~ + ~do~
** Dealing with Multiple Conditions
~cond~
The bracketing is reduced in comparision with elisp
#+begin_src clojure
(defn shipping-charge [preferred-customer order-amount]
  (cond preferred-customer 0.0
        (< order-amount 50) 5.0
        (< order-amount 100) 10
        (>= order-amount 100) (* order-amount 0.10)))
;; => #'user/shipping-charge
#+end_src

~:else~
#+begin_src clojure
(defn shipping-charge [preferred-customer order-amount]
  (cond preferred-customer 0.0
        (< order-amount 50) 5.0
        (< order-amount 100) 10
        :else (* order-amount 0.10)))
;; => #'user/shipping-charge
#+end_src

~case~
#+begin_src clojure
(defn customer-greeting [status]
  (case status
    :gold "Welcome, golden member!!!"
    :preferred "Welcome back!"
    "Welcome to Blotts Books"))
;; => #'user/customer-greeting
#+end_src
** Throwing and Catching
throw, ex-info
#+begin_src clojure
(defn publish-book [book]
  (when (not (:title book))
    (throw (ex-info "A book needs a title!" {:book book})))
  ;;...
  )
;; => #'user/publish-book
#+end_src
^ex-info throws an exception of type clojure.lang.ExceptionInfo

try, catch
#+begin_src clojure
(try
  (publish-book book)
  (catch ArithmeticException e (println "Math problem."))
  (catch StackOverflowError e (println "Unable to publish..")))
;; => nil
(try
  (publish-book {:author "Dickens"})
  (catch ArithmeticException e (println "Math problem."))
  (catch StackOverflowError e (println "Unable to publish.."))
  (catch clojure.lang.ExceptionInfo e (println e)))
;; => nil
#+end_src
** In the  wild
Leiningen
Korma
** Staying Out of trouble
Avoid testing for ~true~ explicitly using ~=~
Prefer truthy and falsy
* More capable Functions
** One Function, different parameters
Either one or two arguments
#+begin_src clojure
(defn greet
  ([to-whom] (println "Welcome to Blotts Books" to-whom))
  ([message to-whom] (println message to-whom)))
;; => #'user/greet
#+end_src

#+begin_src clojure :results output
(greet "Dolly")
(greet "Howdy" "Stranger")
#+end_src

#+RESULTS:
| Welcome to Blotts Books Dolly |
| Howdy Stranger                |

This is called as multi-arity function

How to avoid duplication
#+begin_src clojure
(defn greet
  ([to-whom] (greet "Welcome to Blotts Books" to-whom))
  ([message to-whom] (println message to-whom)))
;; => #'user/greet
#+end_src

#+begin_src clojure :results output
(greet "Dolly")
(greet "Howdy" "Stranger")
#+end_src

#+RESULTS:
| Welcome to Blotts Books Dolly |
| Howdy Stranger                |
** Arguments with Wild Abandon
arbitrary number of arguments
#+begin_src clojure
(defn print-any-args [& args]
  (println "My arguments are:" args))
;; => #'user/print-any-args

(defn first-argument [& args]
  (first args))
(defn first-argument2 [x & args]
  x)
#+end_src
These are called as var-arg or variadic functions
** Multimethods
Vary the method call based on some property of data

Books of various formats
#+begin_src clojure
(def book1 {:title "War and Peace" :author "Tolstoy"})
;; => #'user/book1
(def book2 {:book "Emma" :by "Austen"})
;; => #'user/book2
(def book3 ["1984" "Orwell"])
;; => #'user/book3

;;normalize book to format {:title ? :author ?}
(defn normalize-book [book]
  (if (vector? book)
    {:title (first book) :author (second book)}
    (if (contains? book :title)
      book
      {:title (:book book) :author (:by book)})))
;; => #'user/normalize-book
(normalize-book book1)
;; => {:title "War and Peace", :author "Tolstoy"}
(normalize-book book2)
;; => {:title "Emma", :author "Austen"}
(normalize-book book3)
;; => {:title "1984", :author "Orwell"}
#+end_src
^above becomes a little messy as we keep adding more book formats

If we had to add a new type of book format, having multimethods will ?enable us to make minimal changes.
Look into SICP/data-directed programming as to why this is in detail.

dispatch aka type finder function
#+begin_src clojure
(defn dispatch-book-format [book]
  (cond (vector? book) :vector-book
        (contains? book :title) :standard-map
        (contains? book :book) :alternative-map))
;; => #'user/dispatch-book-format
#+end_src

Now we declare a multi method that uses the above dispatch function
#+begin_src clojure
(defmulti normalize-book dispatch-book-format)
;; => #'user/normalize-book
#+end_src

implementation of multimethod
#+begin_src clojure
(defmethod normalize-book :vector-book [book]
  {:title (first book) :author (second book)})
;; => #multifn[normalize-book 0x6aa71187]
(defmethod normalize-book :standard-map [book]
  book)
;; => #multifn[normalize-book 0x6aa71187]
(defmethod normalize-book :alternative-map [book]
  {:title (:book book) :author (:by book)})
;; => #multifn[normalize-book 0x6aa71187]
#+end_src

#+begin_src clojure
(normalize-book book1)
;; => {:title "War and Peace", :author "Tolstoy"}
(normalize-book book2)
;; => {:title "Emma", :author "Austen"}
(normalize-book book3)
;; => {:title "1984", :author "Orwell"}
#+end_src

You can supply a method for =:default= that will be called if none of the argument's type matches none of the above.

This is clojure's way of doing Type-based polymorphism found in OOP languages
** Deeply Recursive
#+begin_src clojure
(def books [{:title "Jaws" :copies-sold 2000000}
            {:title "Emma" :copies-sold 3000000}
            {:title "2001" :copies-sold 4000000}])
;; => #'user/books
(defn sum-copies
  ([books] (sum-copies books 0))
  ([books total] (if (empty? books)
                   total
                   (sum-copies (rest books) (+ total (:copies-sold (first books)))))))
;; => #'user/sum-copies
(sum-copies books)
;; => 9000000
#+end_src
But this can cause stackoverflow, with as little as 4000 books.

Tail call optimization using ~recur~:-
#+begin_src clojure
(defn sum-copies
  ([books] (sum-copies books 0))
  ([books total]
   (if (empty? books)
     total
     (recur (rest books) (+ total (:copies-sold (first books)))))))
#+end_src
All we did is replace the /recursive/ call to ~sum-copies~ with ~recur~

To get rid of needing a new arity just for recursive call, we make use of ~loop~
#+begin_src clojure
(defn sum-copies [books]
  (loop [books books total 0]
    (if (empty? books)
      total
      (recur (rest books) (+ total (:copies-sold (first books)))))))
#+end_src
Kinda looks like ~let~ expression

~loop~ works with ~recur~
Whenever a ~recur~ is hit, the values passed into ~recur~ will be bound to the symbols of the ~loop~, and the ~loop~ expression is evaluated again.

~recur~ with or without loop, is the tool that enables us to re-evaluate some block again and again.
** Docstrings
Note that *the arguments list is written after the docstring*
#+begin_src clojure
(defn average
  "Return the average of a and b"
  [a b]
  (/ (+ a b) 2.0))
;; => #'user/average
#+end_src
This ordering makes sense:-
After all, if the docstring were written after the arguments list, it would be treated as an expression inside the function body.

#+begin_src clojure :results output
(doc average)
#+end_src

#+RESULTS:
: -------------------------
: user/average
: ([a b])
:   Return the average of a and b

#+begin_src clojure
(def pi "The math constant Pi" 3.14)
;; => #'user/pi
#+end_src

#+begin_src clojure :results output
(doc pi)
#+end_src

#+RESULTS:
: -------------------------
: user/pi
:   The math constant Pi
** Pre and Post Conditions
Lets say we want to always ensure a book has a title before publishing
#+begin_src clojure
(defn publish-book [book]
  (when-not (contains? book :title)
    (throw (ex-info "Books must contain :title" {:book book})))
  (print-book book)
  (ship-book book))
#+end_src

Clojure provides a way to do the above neatly.
#+begin_src clojure
(defn publish-book [book]
  {:pre [(:title book)]}
  (print-book book)
  (ship-book book))
#+end_src

There can be multiple pre conditions
#+begin_src clojure
(defn publish-book [book]
  {:pre [(:title book) (:author book)]}
  (print-book book)
  (ship-book book))
#+end_src

There can be post conditions. The =%= represents /ret/ from the function
#+begin_src clojure
(defn publish-book [book]
  {:pre [(:title book) (:author book)]
   :post [(boolean? %)]}
  (print-book book)
  (ship-book book))
#+end_src

If any of the conditions are not met, a runtime exception is thrown.
** Staying out of trouble
Always leave a space between =&= and =args= when defining variadic functions
** In the wild
Implementation of *=*
Use cider repl and =M-.= to get to this definition.
[[file:~/.m2/repository/org/clojure/clojure/1.11.3/clojure-1.11.3.jar:clojure/core.clj::(defn =]]
The =m2= folder is where leiningen stores all project dependencies.

Implementation of the builtin ~to-url~ in clojurescript
[[file:clojurescript/src/main/clojure/cljs/js_deps.cljc::defmulti to-url class]]
* Functional Things
Functions are first class values in clojure
Clojurists regularly write functions that write other functions.
** Functions are values
#+begin_src clojure
(def dracula {:title "Dracula" :author "Stoker" :price 1.99 :genre :horror})
;; => #'user/dracula
#+end_src

#+begin_src clojure
(defn cheap? [book]
  (when (<= (:price book) 9.99)
    book))
;; => #'user/cheap?
(defn pricey? [book]
  (when (> (:price book) 9.99)
    book))
;; => #'user/pricey?
(cheap? dracula)
;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
(pricey? dracula)
;; => nil
#+end_src

#+begin_src clojure
(defn horror? [book]
  (when (= (:genre book) :horror)
    book))
;; => #'user/horror?
(defn adventure? [book]
  (when (= (:genre book) :adventure)))
;; => #'user/adventure?
(horror? dracula)
;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
(adventure? dracula)
;; => nil
#+end_src

#+begin_src clojure
(defn cheap-horror? [book]
  (when (and (cheap? book) (horror? book))
    book))
;; => #'user/cheap-horror?
(defn pricy-adventure? [book]
  (when (and (pricey? book) (adventure? book))
    book))
;; => #'user/pricy-adventure?
#+end_src

How can we create such combinations dynamically as need arises:-
#+begin_src clojure
(defn both? [first-predicate-f second-predicate-f book]
  (when (and (first-predicate-f book) (second-predicate-f book))
    book))
;; => #'user/both?
(both? cheap? horror? dracula)
;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
(both? pricey? adventure? dracula)
;; => nil
#+end_src
** Functions on the fly
+aka lambda functions+
#+begin_src clojure
(fn [n] (* 2 n))
;; => #function[user/eval8013/fn--8014]
((fn [n] (* 2 n)) 10)
;; => 20

(defn cheaper-f [max-price]
  (fn [book]
    (when (<= (:price book) max-price)
      book)))
;; => #'user/cheaper-f
#+end_src
cheaper-f is a function that returns another function
The returned function remembers the specific max-price that was passed during its creation. Also known as /closure/.

#+begin_src clojure
(def real-cheap? (cheaper-f 1.00))
;; => #'user/real-cheap?
(def kind-of-cheap? (cheaper-f 1.99))
;; => #'user/kind-of-cheap?
(def marginally-cheap? (cheaper-f 5.99))
;; => #'user/marginally-cheap?

(real-cheap? dracula)
;; => nil
(kind-of-cheap? dracula)
;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
(marginally-cheap? dracula)
;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}
#+end_src

A function that +manufactures functions such as+ is sister to ~both?~
#+begin_src clojure
(defn both-f [predicate-f-1 predicate-f-2]
  (fn [book]
    (when (and (predicate-f-1 book) (predicate-f-2 book))
      book)))
;; => #'user/both-f
(def cheap-horror? (both-f cheap? horror?))
;; => #'user/cheap-horror?
(cheap-horror? dracula)
;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}

(def real-cheap-adventure? (both-f real-cheap? adventure?))
;; => #'user/real-cheap-adventure?
(real-cheap-adventure? dracula)
;; => nil

(def real-cheap-horror? (both-f real-cheap? horror?))
;; => #'user/real-cheap-horror?
#+end_src

#+begin_src clojure
(def cheap-horror-possession? (both-f cheap-horror?
                                (fn [book] (when (= (:genre book) :possession))
                                  book)))
;; => #'user/cheap-horror-possession?
#+end_src
** A functional toolkit
apply
#+begin_src clojure
(+ 1 2 3 4)
;; => 10
(apply + [1 2 3 4])
;; => 10
#+end_src

using ~apply~ to convert from one type to another
#+begin_src clojure
(apply str ["One" 2 3 "Four"])
;; => "One23Four"
(apply list ["One" 2 3 "Four"])
;; => ("One" 2 3 "Four")
(apply vector '("One" 2 3 "Four"))
;; => ["One" 2 3 "Four"]
#+end_src

partial
#+begin_src clojure
(inc 42)
;; => 43

(defn my-inc [n] (+ n 1))
;; => #'user/my-inc
(my-inc 42)
;; => 43

(def my-inc2 (partial + 1))
;; => #'user/my-inc2
(my-inc2 42)
;; => 43
#+end_src
notice that partial will bind the *first* argument of ~+~ to ~1~

Using ~partial~ to redefine our cheapness predicates
~partial~ eliminates the need for closure creating functions such as =cheaper-f=
But it requires a =cheaper-than= helper
#+begin_src clojure
(defn cheaper-than [max-price book]
  (when (<= (:price book) max-price)
    book))
;;^notice that we want to keep /max-price/ as the first argument, so that partial can handle it

;; => #'user/cheaper-than
(def real-cheap? (partial cheaper-than 1.00))
;; => #'user/real-cheap?
(def kind-of-cheap? (partial cheaper-than 1.99))
;; => #'user/kind-of-cheap?
(def marginally-cheap? (partial cheaper-than 5.99))
;; => #'user/marginally-cheap?
#+end_src

~complement~
#+begin_src clojure
(defn not-adventure? [book]
  (when (not (adventure? book))
    book))
;; => #'user/not-adventure?
(not-adventure? dracula)
;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}

(defn not-adventure? [book] (not (adventure? book)))
;; => #'user/not-adventure?
(not-adventure? dracula)
;; => {:title "Dracula", :author "Stoker", :price 1.99, :genre :horror}

(def not-adventure? (complement adventure?))
;; => #'user/not-adventure?
(not-adventure? dracula)
;; => true
#+end_src

~every-pred~ is a builtin variadic version of ~both?~
#+begin_src clojure
(def cheap-horror? (every-pred cheap? horror?))
;; => #'user/cheap-horror?

(def cheap-horror-possession? (every-pred cheap? horror? (fn [book]
                                                           (when (= (:genre book) :possession)
                                                             book))))
;; => #'user/cheap-horror-possession?
#+end_src
** Function literals, also called lambdas
these are even more minimal way of defining functions than ~fn~
Its format is just =#= followed by the function body wrapped in parenthesis

~adventure?~ using function literal
#+begin_src clojure
#(when (= (:genre %1) :adventure) %1)

(#(when (= (:genre %1) :adventure) %1) dracula)
;; => nil
#+end_src

double as a function literal
#+begin_src clojure
(#(* %1 2) 10)
;; => 20
#+end_src

for only one argument, even more minimal syntax is:
#+begin_src clojure
(#(* % 2) 10)
;; => 20
#+end_src
** In the wild
Implementation of ~defn~ using ~def~ and ~fn~
[[file:~/.m2/repository/org/clojure/clojure/1.11.3/clojure-1.11.3.jar:clojure/core.clj::(def]]

~update~ accepts parameters that are functions
~update-in~ too

When using Ring, functions as values are extensively used while defining middlewares.
Two nice example middlewares are given in the textbook

A web application is not something magical. It is just a function.
*Traditionally, Ring applications call the final, fully middleware wrapped handler function as the app*
** Staying out of trouble
Always strive to write pure functions
* Let
** A local temporary place for your stuff
Book store, say, discounts if final bill is more than a set minimum. If not, bill the minimum amount.
#+begin_src clojure
(defn compute-discount-amount [amount discount-percent min-charge]
  (if (> (* amount (- 1.0 discount-percent)) min-charge)
    (* amount (- 1.0 discount-percent))
    min-charge))
#+end_src

Intention revealing naming
If we used /def/, such a binding would be visible even outside the function
Because, a /def/ always has global visibility

Also, philosophically, in Clojure, a /def/ is used for binding a global immutable value.
Think of it as equivalent to /const/ binding in C++

#+begin_src clojure
(defn compute-discount-amount [amount discount-percent min-charge]
  (let [discounted-amount (* amount (- 1.0 discount-percent))]
    (if (> discounted-amount min-charge)
      discounted-amount
      min-charge)))
;; => #'user/compute-discount-amount
#+end_src

In cloujure, let behaves similar to elisp's let*
ie bound values are immediately available
#+begin_src clojure
(defn compute-discount-amount [amount discount-percent min-charge]
  (let [discount (* amount discount-percent)
        discounted-amount (* amount discount)]
    (if (> discounted-amount min-charge)
      discounted-amount
      min-charge)))
;; => #'user/compute-discount-amount
#+end_src


** Let over Fn
Say, discount is different for each customer
#+begin_src clojure
(def user-discounts {"Nicholas" 0.10 "Jonathan" 0.07 "Felicia" 0.05})
;; => #'user/user-discounts
#+end_src

Dumb implementation
#+begin_src clojure
(defn compute-discount-amount [amount user-name user-discounts min-charge]
  (let [discount-percent (user-discounts user-name)
        discount (* amount discount-percent)
        discounted-amount (- amount discount)]
    (if (> discounted-amount min-charge)
      discounted-amount
      min-charge)))
#+end_src
^The problem with this approach is that:-
compute-discount-amount is not a pure function
It is kinda implicit that ~compute-discount-amount~ must be evaluated in an environment where ~user-discounts~ is properly bound.

It might be better to make use of a closure to make sure that above implicitness is gotten rid of.
ie, it ensures the above environment condition
#+begin_src clojure
(defn mk-discount-price-f [user-name user-discounts min-charge]
  (let [discount-percent (user-discounts user-name)] ;capture this value as a closure for consumption by the ret function
    (fn [amount]
      (let [discount (* amount discount-percent)
            discounted-amount (- amount discount)]
        (if (> discounted-amount min-charge)
          discounted-amount
          min-charge)))))
;; => #'user/mk-discount-price-f
#+end_src
^This is an example of  an Higher-level function (function returning another function) and
the outer ~let~ and ~fn~ together form a closure

Usage
#+begin_src clojure
;; Get a price function for Felicia
(def compute-felicia-price (mk-discount-price-f "Felicia" user-discounts 10.0))
;; => #'user/compute-felicia-price

;;...sometime later compute a price when she comes to the store
(compute-felicia-price 20.0)
;; => 19.0
#+end_src

** +Variations on above theme+ ~if-let~
~if-let~
#+begin_src clojure
(def anonymous-book {:title "Sir Gawain and the Green Knight"})
;; => #'user/anonymous-book
(def with-author {:title "Once and Future King" :author "White"})
;; => #'user/with-author

(defn uppercase-author [book]
  (let [author (:author book)]
    (if author
      (.toUpperCase author))))
;; => #'user/uppercase-author
(uppercase-author with-author)
;; => "WHITE"
(uppercase-author anonymous-book)
;; => nil

(defn uppercase-author [book]
  (if-let [author (:author book)]
    (.toUpperCase author)
    "ANONYMOUS"))
;; => #'user/uppercase-author
(uppercase-author with-author)
;; => "WHITE"
(uppercase-author anonymous-book)
;; => "ANONYMOUS"
#+end_src
~if-let~ is a misnomer, it should have been called ~let-if~

There is a ~when-let~ builtin as well

** In the wild
In Ring:-
~(defn parse-params~
~(defn assoc-query-params~

Incanter

** Staying out of trouble
~let~  follows lexical scope.  Lexical scope means that bindings created by let have a scope limited by the body of the let expression.
Unlike elisp.
* Def, Symbols, and Vars
** A Global, Stable place for your stuff
def can be used to define global constants
Global constants are capitalized by convention
** Symbols are Things
~def~ binds a symbol to a value
#+begin_src clojure
(def author "Austen")
#+end_src
The above involes one symbol and one value
Both of them are first-class and take up bytes in memory

The symbol is ~'author~
The value is ~"Austen"~

Symbols have a lot in common with keywords.
** Bindings are Things too
When you evaluate a def or defn, aka create a binding, Clojure creates a =var=
#+begin_src clojure
(def author "Austen")
;; => #'user/author
(def title "Emma")
;; => #'user/title
(def PI 3.14)
;; => #'user/PI
(def book1 {:title title :author author})
;; => #'user/book1
(defn book-description [book] (str (:title book) " written by " (:author book)))
;; => #'user/book-description
#+end_src

What these^ =var= looks like:-
[[xournalpp:two-slotted-var.xopp][var has two slots]]

*Sharp-quote* can be used to get a var that created some symbol
#+begin_src clojure
;;makes a var:-
(def author "Austen")
;; => #'user/author

;;Get above created var:-
#'author
;; => #'user/author

(def the-var #'author)
;; => #'user/the-var

(.get the-var)
;; => "Austen"
(.-sym the-var)
;; => author
#+end_src
** Varying Your Vars
Vars are mutable in Clojure. This is helpful during development.
But, in production, respect the convention of not changing a var once its defined.
Aka, never change a once defined ~def~ and  ~defn~

#+begin_src clojure
;;Make a dynmic-var
(def ^:dynamic *debug-enabled* false)

(defn debug [msg]
  (if *debug-enabled*
    (println msg)))

(binding [*debug-enabled* true]
  (debug "Calling that bug prone function:-")
  (some-troublesome-function-that-needs-logging) ;;for this call and all call stacks below it, the dynamic var setting remains ~true~
  (debug "Back from that bug prone function."))
#+end_src

~binding~ :- Helps you change a symbol without resorting to the BAD anti-pattern of using ~def~ inside a ~defn~
+symbols+ vars intended to be used in ~binding~ are called dynamic vars

By convention, they are sorrounded by =*=
They are called as sorrounded by earmuffs
** Staying out of trouble
Note:-
~let~ does not create var
#+begin_src clojure
(let [let-bound-symbol 42]
  #'let-bound-symbol)
;; => Syntax error compiling var at (readme.org::Def, Symbols, and Vars:67:1).
;;    Unable to resolve var: let-bound-symbol in this context
#+end_src
SICP taught me that ~let~ is just syntactic sugar for a lambda definition and that lambda being called
** In the wild
clojure/core.clj file
clojure/core_print.clj file

~set!~ changes the value of a dynamic-var 'from inside the binding'

=*1=, =*2= and =*3= are dynamic vars with a single earmuff
They represent the last ret, last to last ret and the third last ret respectively

=*e= represents the last exception

** Wrapping up
*def creates a var(a Clojure value) which is an association between another Clojure value (a symbol) and a third value*

Dynamic vars are vars that let you swap in a new value while you evaluate an expressin or six
* Namespaces
Namespace is the mechanism that Clojure uses to organize vars into related buckets.
** A place for your vars
vars live in namespaces

Conceptually, a namespace is just a big lookup table of vars, indexed by their symbols
*You can visualise a namespace as follows:-*
[[xournalpp:namespace visualisation.xopp]]

Auto created default namespace is named as 'user'
However, if =lein repl= is run inside a project, the default namespace is named as '<project_name>.core'

Create a new namespace
#+begin_src clojure
(ns pricing)
;; => nil
#+end_src
Notice no quotation of necessary for argument

Above creates and activates that namespace
#+begin_src clojure
(def discount-rate 0.15)
;; => #'pricing/discount-rate
(defn discount-price [book]
  (* (- 1.0 discount-rate) (:price book)))
;; => #'pricing/discount-price
#+end_src

Switch back to an existing namespace is also done using ~ns~
#+begin_src clojure
(ns user)
;; => nil
discount-rate
;; => Syntax error compiling at (Getting_Clojure.org::Namespaces:0:0).
;;    Unable to resolve symbol: discount-rate in this context
(ns pricing)
;; => nil
discount-rate
;; => 0.15
#+end_src

Fully qualified symbol = <ns>/<symbol name>
Such long name makes a symbol defined in one namespace available in another
#+begin_src clojure
(ns user)
;; => nil
(pricing/discount-price {:title "Emma" :price 9.99})
;; => 8.4915
#+end_src
** Loading Namespaces using ~require~
You need to make sure the namespace you want to use is loaded before you try to use it.
~(require <quoted name>)~
or
~(require '[<name> :as blabla])~

(Aside: We will learn another way to loading namespaces later in this chapter using ~(ns <bla> (:require <unquoted>))~)

Eg: =clojure.data= is a builtin namespace. (The dot is part of the name of this namespace)
Say, I need to use ~diff~ which is defined in that namespace.
#+begin_src clojure
(def literature ["Emma" "Oliver Twist" "Possession"])
;; => #'user/literature
(def horror ["It" "Carry" "Possession"])
;; => #'user/horror

(clojure.data/diff literature horror)
;; => Execution error (ClassNotFoundException) at java.net.URLClassLoader/findClass (URLClassLoader.java:445).
;;    clojure.data
#+end_src
^Because, namespace not yet loaded

Tell Clojure to read and compile the code behind some namespace:-
#+begin_src clojure
(require 'clojure.data)
;; => nil
(clojure.data/diff literature horror)
;; => [["Emma" "Oliver Twist"] ["It" "Carry"] [nil nil "Possession"]]
#+end_src
** A namespace of your own
(From here till 'In the wild' of this chapter, its more convenient to work inside a ~lein repl~)

blottsbooks

Create a file src/blottsbooks/pricing.clj
This corresponds to the namespace:-
~(ns blottsbooks.pricing)~

** (~:require~ + As) and Refer
#+begin_src clojure
(ns blottsbooks.core
  (:require [blottsbooks.pricing :as pricing])
  (:gen-class))
#+end_src

#+begin_quote repl output
[anup@imac0 blottsbooks]$ lein repl

blottsbooks.core=> pricing/discount-rate
0.15
blottsbooks.core=> pricing/discount-price 
#object[blottsbooks.pricing$discount_price 0x6d7c552 "blottsbooks.pricing$discount_price@6d7c552"]
#+end_quote

*^Visualise as:-*
[[xournalpp:require-visualised.xopp]]

Avoid using ~:refer~ and mostly prefer to using ~:as~

** Namespaces, Symbols and Keywords
Q: Are namespaces first class citizens in Clojure? Yes!
Namespaces are just ordinary Clojure values
Eg:-
The current namespace is bound to the symbol ~*ns*~  (Recall that earmuffs represent dynamic vars)
#+begin_src clojure :results output
(println "Current ns:" *ns*)
#+end_src

#+RESULTS:
: Current ns: #namespace[user]

Look up a namespace. Useful to check the existence of some namespace.
#+begin_src clojure
(find-ns 'user)
;; => #namespace[user]
(find-ns 'doesnt-exist)
;; => nil
#+end_src

Map  the things defined in some namespace
#+begin_src clojure
(ns-map 'user)
;; => {primitives-classnames #'clojure.core/primitives-classnames,
;;     +' #'clojure.core/+',
;;     Enum java.lang.Enum,
;;     decimal? #'clojure.core/decimal?,
;;     restart-agent #'clojure.core/restart-agent,
;;     sort-by #'clojure.core/sort-by,
;;     ...,
;;     refer-clojure #'clojure.core/refer-clojure}

(ns-map 'doesnt-exist)
;; => Execution error at user/eval10058 (REPL:118).
;;    No namespace: doesnt-exist found

(namespace 'some-namespace/some-symbol)
;; => "some-namespace"
#+end_src
^(cant be used to check the existence of some namespace without writing code to catch exceptions etc... so prefer ~find-ns~ for such check)

Keywords can be namespaced too, but are seldom done.

** In the wild
clojure.core :- ~(require '[clojure.core :refer :all])~
---------------------------------------------------------------------------------------------------

*How to include a dependency into your project:-*
Eg:
Say you want to include the KormaSQL library

Go to that library's homepage or github and figure out the latest version
Github readme says ~[korma "0.4.3"]~

Include this array into ~projects.clj~ file created by leiningen
Next time you run ~lein repl~, that dependency gets downloaded and included

Now, how to figure out what argument to pass to ~'require~
Looking at the example from the readme, I see that the first line is ~(use 'korma.db)~
From this, I get my argument ~korma.db~
aka
~[korma.db :as db]~

#+begin_quote bash output
[anup@imac0 blottsbooks]$ lein repl
Retrieving korma/korma/0.4.3/korma-0.4.3.pom from clojars
Retrieving org/clojure/clojure/1.8.0/clojure-1.8.0.pom from central
Retrieving com/mchange/c3p0/0.9.5.2/c3p0-0.9.5.2.pom from central
Retrieving com/mchange/mchange-commons-java/0.2.11/mchange-commons-java-0.2.11.pom from central
Retrieving org/clojure/java.jdbc/0.6.1/java.jdbc-0.6.1.pom from central
Retrieving org/clojure/clojure/1.4.0/clojure-1.4.0.pom from central
Retrieving org/sonatype/oss/oss-parent/5/oss-parent-5.pom from central
Retrieving com/mchange/c3p0/0.9.5.2/c3p0-0.9.5.2.jar from central
Retrieving com/mchange/mchange-commons-java/0.2.11/mchange-commons-java-0.2.11.jar from central
Retrieving org/clojure/java.jdbc/0.6.1/java.jdbc-0.6.1.jar from central
Retrieving korma/korma/0.4.3/korma-0.4.3.jar from clojars
nREPL server started on port 37507 on host 127.0.0.1 - nrepl://127.0.0.1:37507
REPL-y 0.5.1, nREPL 1.0.0
Clojure 1.11.1
OpenJDK 64-Bit Server VM 21.0.4+7-LTS
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

blottsbooks.core=> (require '[korma.db :as db])
nil
blottsbooks.core=> (count (ns-map 'korma.db))
796
 blottsbooks.core=> 
#+end_quote
**  Staying out of trouble
The =.= in a namespace doesnt have any special meaning to Clojure.

Pass ~:reload~ keyword to re-evaluate a namespace. By default, already included namespace isnt evaluated, even if the source code has new edits.

~defonce~ can be used to bind a symbol to a value, with the special property that this binding happens exactly once. The very first time you include that namespace.
Subsequent ~:reload~ refuses to re-run those bindings. This is helpful when you have function with side effects or those that take a long time to finish.

~ns-unmap~ can be used to unbind a ?symbol

*This marks the end of Part I - Basics -------------------------------------------------------------*
Next starts *Part II - Intermediate*

* Part II ---------------------------------------------------------------------------------------------------
:PROPERTIES:
:UNNUMBERED: t
:END:

* Sequences
Clojure code *isnt* written with specificity to each collection type: map, set, vector, list
It *is* written to a sequence_abstract_type0

** One thing after another
How can we implement a ~count~ that works on all collection types:-
Option1. multimethod + specific defmethod implementation for each type
Option2. normal function that works on a seq + collection type turned into a seq by making use of a wrapper_function(<specific_type>) = <seq_type>
*Clojure chooses Option 2* (This is known as Adapter-Pattern in OOP circles)

#+begin_quote What is a Sequence?
Clojure calls its generic collection wrappers [as] sequences. Under the hood, there are as mnay flavors of sequences as there are collection types, but to the outside world all sequences provide a very uniform interface: no matter if it's a vector or a map or a list or a set behind a sequence, one sequence looks exactly like another.
#+end_quote

What a seq looks like
#+begin_src clojure
(def book-title-seq (seq ["Emma" "Oliver Twist" "Robinson Crusoe"]))
;; => #'user/book-title-seq
book-title-seq
;; => ("Emma" "Oliver Twist" "Robinson Crusoe")
#+end_src
*Dont be fooled by the round parenthesis into thinking its a list type*
Its a seq

#+begin_src clojure
(seq '("Emma" "Oliver Twist" "Robinson Crusoe"))
;; => ("Emma" "Oliver Twist" "Robinson Crusoe")
(seq {:title "Emma", :author "Austen", :published 1815})
;; => ([:title "Emma"] [:author "Austen"] [:published 1815])
;; ^order not guranteed

(seq (seq [1 2 3]))
;; => (1 2 3)
#+end_src


seq returns nil if empty
#+begin_src clojure
(seq [])
;; => nil
(seq '())
;; => nil
(seq '{})
;; => nil
#+end_src
^ ~(seq <some collection)~ can therefore be used as a truthy value
** A Universal interface - with a foursome of functions
1. first
2. rest
3. next 
4. cons

From hereon, this chapter feels a lot like Ch-1 of SICP

~next~ unlike ~rest~, returns nil if empty
#+begin_src clojure
(next [1])
;; => nil
(rest [1])
;; => ()
#+end_src

Lets get a feel for these four functions
#+begin_src clojure
(first (seq '("Emma" "Oliver Twist" "Robinson Crusoe")))
;; => "Emma"
(rest (seq '("Emma" "Oliver Twist" "Robinson Crusoe")))
;; => ("Oliver Twist" "Robinson Crusoe")
(next (seq '("Emma" "Oliver Twist" "Robinson Crusoe")))
;; => ("Oliver Twist" "Robinson Crusoe")
(cons "Mahabharata" '("Emma" "Oliver Twist" "Robinson Crusoe"))
;; => ("Mahabharata" "Emma" "Oliver Twist" "Robinson Crusoe")
#+end_src
*And, that's it. These are the only four primitive functions necessary to define a huge number of sequence functions*

Lets try to implement ~my-count~
#+begin_src clojure
;;my own try:-
(defn my-count [col]                    ;col stands for collection, aka, any collection type
  (loop [col-s (seq col)
         ret 0]
    (if (next col-s)
      (recur (next col-s) (+ ret 1))
      (+ ret 1))))
;; => #'user/my-count
(my-count [9 3 5])
;; => 3
(my-count [nil nil nil])
;; => 3

;;textbook:-
(defn my-count [col]
  (let [the-seq (seq col)]
    (loop [ret 0 s the-seq]
      (if (seq s)                       ;to take care of turning the final [] into nil
        (recur (inc ret) (rest s))
        ret))))
(my-count [9 3 5])
;; => 3
(my-count [nil nil nil])
;; => 3
#+end_src

^Anup self tip: Prefer to use ~rest~ over ~next~
Because ~rest~ always returns a seq-type. So, results in cleaner code type wise.
Unlike ~next~ which can return either a seq-type or nil

~my-count~ implementation follows a pattern,
1. turn collection into a sequence
2. use the foursome to manipulate this seq
*This is the common pattern in which even the builtin seq functions are implemented*
   
** A Rich Toolkit - the large number of useful builtin seq functions provided by Clojure
#+begin_src clojure
(count [9 2 5])
;; => 3
(def titles ["Jaws" "Emma" "2001" "Dracula"])
;; => #'user/titles
(reverse titles)
;; => ("Dracula" "2001" "Emma" "Jaws")
(sort titles)
;; => ("2001" "Dracula" "Emma" "Jaws")
(reverse (sort titles))
;; => ("Jaws" "Emma" "Dracula" "2001")
(def titles-and-authors ["Emma" "Austen" "Jaws" "Benchley"])
;; => #'user/titles-and-authors
(partition 2 titles-and-authors)
;; => (("Emma" "Austen") ("Jaws" "Benchley"))

(def titles ["HackersPainters" "Emma"])
;; => #'user/titles
(def authors '("PGraham" "Austen"))
;; => #'user/authors
(interleave titles authors)
;; => ("HackersPainters" "PGraham" "Emma" "Austen")
;;;;;;;; interleave combines two sequences into a single sequence. So, kinda like ~append~ in scheme

(def scary-animals ["lion" "tiger" "crocodile"])
;; => #'user/scary-animals
(interpose "and" scary-animals)
;; => ("lion" "and" "tiger" "and" "crocodile")
#+end_src

** ...Made Richer with Functional Values
ie adding the awesome 'functions are values' to above 'sequence abstract type' idea makes for a beautiful experience

#+begin_src clojure
(filter neg? '(1 9 -2 4 -8 5 -23))
;; => (-2 -8 -23)

(def books [{:title "Deep Six" :price 13.99 :genre :sci-fi :rating 6}
            {:title "Dracula" :price 1.99 :genre :horror :rating 7}
            {:title "Emma" :price 7.99 :genre :comedy :rating 9}
            {:title "2001" :price 10.50 :genre :sci-fi :rating 5}])
;; => #'user/books
(defn cheap? [book]
  (if (<= (:price book) 9.99)
    book))
;; => #'user/cheap?
(filter cheap? books)
;; => ({:title "Dracula", :price 1.99, :genre :horror, :rating 7}
;;     {:title "Emma", :price 7.99, :genre :comedy, :rating 9})

(some cheap? books)
;; => {:title "Dracula", :price 1.99, :genre :horror, :rating 7}
;; Mnemonic:- Is there some item that passes the test?
#+end_src

** Map
#+begin_src clojure
(map inc [0 5 9])
;; => (1 6 10)

books
;; => [{:title "Deep Six", :price 13.99, :genre :sci-fi, :rating 6}
;;     {:title "Dracula", :price 1.99, :genre :horror, :rating 7}
;;     {:title "Emma", :price 7.99, :genre :comedy, :rating 9}
;;     {:title "2001", :price 10.5, :genre :sci-fi, :rating 5}]

(map :title books)
;; => ("Deep Six" "Dracula" "Emma" "2001")
;; This trick with keywords being functions makes code succinct

;; Lengths of the titles
(map (comp count :title) books)
;; => (8 7 4 4)
#+end_src

~comp~ *accepts a bunch of functions and returns a function that is effectively the same as*
*applying each of the argument functions one after another, right to left*
I was not able to recall the name of this function. I found that ChatGPT was very useful in finding the answer.
Whereas google search couldnt help me find it.

~for~ is not popular in Clojure circles. Still, obligatory example:-
#+begin_src clojure
(for [b books]
  (count (:title b)))
;; => (8 7 4 4)
#+end_src
Clojure's *for* returns a seq.

** Reduce
Combines all the elements of a collection into a single value
#+begin_src clojure
(reduce + 100 [1 2 3 4])
;; => 110
(reduce + [1 2 3 4])
;; => 10
#+end_src
If you exclude the initial value, then ~reduce~ will consider the first element of the collection as the initial value.

*Reduce is not only for adding numbers*
It can be used whenever you want to turn a sequence into some single value.

Eg:-
Find the highest priced  book (my own version)
#+begin_src clojure
books
;; => [{:title "Deep Six", :price 13.99, :genre :sci-fi, :rating 6}
;;     {:title "Dracula", :price 1.99, :genre :horror, :rating 7}
;;     {:title "Emma", :price 7.99, :genre :comedy, :rating 9}
;;     {:title "2001", :price 10.5, :genre :sci-fi, :rating 5}]
(reduce (fn [b1 b2] (if (> (:price b1) (:price b2)) b1 b2)) books)
#+end_src

textbook version has a mistake:
It finds the price of the highest priced book. Not the highest priced book as described in question.
#+begin_src clojure
(defn hi-price [current-highest-price book]
  (if (> (:price book) current-highest-price)
    (:price book)
    current-highest-price))
;; => #'user/hi-price

(reduce hi-price 0 books)
;; => 13.99
#+end_src

** Composing a Solution
Get the top 3 bestrated books as a string seperated by " // "
#+begin_src clojure
books
;; => [{:title "Deep Six", :price 13.99, :genre :sci-fi, :rating 6}
;;     {:title "Dracula", :price 1.99, :genre :horror, :rating 7}
;;     {:title "Emma", :price 7.99, :genre :comedy, :rating 9}
;;     {:title "2001", :price 10.5, :genre :sci-fi, :rating 5}]

(sort-by :rating books)
;; => ({:title "2001", :price 10.5, :genre :sci-fi, :rating 5}
;;     {:title "Deep Six", :price 13.99, :genre :sci-fi, :rating 6}
;;     {:title "Dracula", :price 1.99, :genre :horror, :rating 7}
;;     {:title "Emma", :price 7.99, :genre :comedy, :rating 9})

(defn format-top-titles [books]
  (reduce str (interpose " // " (map :title (take 3 (reverse (sort-by :rating books)))))))
;; => #'user/format-top-titles

(format-top-titles books)
;; => "Emma // Dracula // Deep Six"
#+end_src
*You can get a lot of computing out of a few sequence functions.*
Remember that even SICP taught me the same.

** Other Sources of Sequences
You can turn a lot of things into sequences, besides vectors, lists, sets, maps

~line-seq~ turns a text file into a sequence of its lines
#+begin_src clojure
(require '[clojure.java.io :as io])
;; => nil
(defn listed-author? [author]
  (with-open  [r (io/reader "authors.txt")]
    (some (partial = author) (line-seq r))))
;; => #'user/listed-author?
(listed-author? "Paul Graham")
;; => true
#+end_src

~re-seq~ turns regular expression matches into a sequence
#+begin_src clojure
(def re #"Pride and Prejudice.*")
;; => #'user/re
(def title "Pride and Prejudice and Zombies")
;; => #'user/title
(if (re-matches re title)
  (println "This is either a classic or a riff on it"))
;; => nil

(re-seq #"\w+" title)
;; => ("Pride" "and" "Prejudice" "and" "Zombies")
#+end_src
Notice that =#(= is used for function literals whereas =#"= is used for regular expression
** In the wild
Overtone
Clojurescript

~-->>~ syntactic sugar places each step of computation at the end
#+begin_src clojure
books
;; => [{:title "Deep Six", :price 13.99, :genre :sci-fi, :rating 6}
;;     {:title "Dracula", :price 1.99, :genre :horror, :rating 7}
;;     {:title "Emma", :price 7.99, :genre :comedy, :rating 9}
;;     {:title "2001", :price 10.5, :genre :sci-fi, :rating 5}]

;;harder to read
(defn format-top-titles [books]
  (reduce str (interpose " // " (map :title (take 3 (reverse (sort-by :rating books)))))))
;; => #'user/format-top-titles
(format-top-titles books)
;; => "Emma // Dracula // Deep Six"

;;easier to read
(defn format-top-titles [books]
  (->>
    books
    (sort-by :rating)
    reverse                             ;;no need to write it as ~(reverse)~
    (take 3)
    (map :title)
    (interpose " // ")
    (reduce str)))
;; => #'user/format-top-titles
(format-top-titles books)
;; => "Emma // Dracula // Deep Six"
#+end_src

~->~ syntactic sugar places it (each step of computation) at the begining
** Staying out of trouble
Avoid processing sequence items one at a time. Its a Clojure antipattern.
Eg: ~for~ is seldom used by Clojurists, they prefer ~map~

Turning a specialized collection into a generic sequence leads to loss of its specialized talents.
Eg: After turning a_map into a a_seq, the fast key-value access property is lost.

There are functions that do not return a seq type, instead returning the same type of collection as its argument.
Eg: ~conj~, (unlike cons)
Such function's implementation has special code for each collection type, unlike seq-functions which only make use of the foursome.

#+begin_quote Dont avoid seqs
None of this means sequences are bad or that you should always fight the natural drift towards them. On the contrary, having a universal abstraction that allows you to work with vectors and sets and lists without constantly worrying about which you have is incredibly useful. But you do need to be mindful of when you have the actual thing and when you have the sequence.
#+end_quote
* Lazy Sequences
made possible by combining previous ideas:-
1. Functional programming
2. Sequence abstraction

Laziness is a virtue. Aside: AirBnB founder said "You have to earn the right to ship a new feature for your user."

Aside:- Doubt? Where is Laziness on the spectrum between: 1. Optimize time complexity while sacrificing space complexity and 2. vice versa.
Ans try1: It is not one or the other.
       Laziness enables us to represent infinity. (apart from allowing use to defer computation)
       Both infinitely large dataset as well as infinitely long computation

** Sequences without End
The sequence api is abstract.
As long as it satisfies foursome, its a seq. That's it.

So, even if we make up return values of ~first~, ~next~ and ~rest~ on the fly,
we still have a seq.
ie It isnt necessary for a seq to have a one on one mapping to some collection type.

Create a test book with nonsense content. The nonsense is a repetition of a proverb.
#+begin_src clojure
;;the proverb
(def jack "All work and no play makes Jack a dull boy.")
;; => #'user/jack

;;dummy textbook
(def text [jack jack jack jack jack jack])
;; => #'user/text
text
;; => ["All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."]

(set! *print-length* 20)
;; => 20

(repeat jack)
;; => ("All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy."
;;     ...)

(def text (repeat jack))
;; => #'user/text
#+end_src

The ret from repeat is infinitely long.
Also, its lazy, ie, it waits until its asked to generate a value by those foursome.

A *Lazy sequence* is one that waits to be asked before it generates its elements.
An *Unbounded sequence* is always a lazy sequence, that goes on forever.

Not all lazy sequences are unbounded.

~take~ is useful while dealing with unbounded sequences.
#+begin_src clojure
(take 2 text)
;; => ("All work and no play makes Jack a dull boy."
;;     "All work and no play makes Jack a dull boy.")
#+end_src

** More interesting laziness
~cycle~ and ~iterate~
#+begin_src clojure
(cycle [1 2 3])
;; => (1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 ...)
(iterate inc 4)
;; => (4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ...)
(def numbers (iterate inc 1))
;; => #'user/numbers
#+end_src

** Lazy friends
~take~ is itself lazy.

Therefore, both these take approximately same amount of time.
#+begin_src clojure
(println (take 20 (iterate inc 1)))
;; => nil
(println (take 20 (take 1000000000 (iterate inc 1))))
;; => nil
#+end_src

~map~ is also lazy.
#+begin_src clojure
(def evens (map #(* 2 %) (iterate inc 1)))
#+end_src

~iterleave~ is lazy as well.
So, we can safely interleave infinite sequences.
#+begin_src clojure
(interleave numbers evens)
;; => (1 2 2 4 3 6 4 8 5 10 6 12 7 14 8 16 9 18 10 20 ...)
#+end_src

In fact, a lot of sequence functions are lazy

*Visualization for lazy sequences*
Think of it as a just in time factory line
ie Production kicks off only after you ask for an element from it.

** Laziness in practise - an example
Eg: Generate a book series, with twenty authors. Every twentieth book of the series is by one of the authors.

What a series looks like:-
#+begin_src clojure
(def numbers [1 2 3])
;; => #'user/numbers
(def trilogy (map #(str "Fifty shades of gray, Book " %) numbers))
;; => #'user/trilogy
trilogy
;; => ("Fifty shades of gray, Book 1"
;;     "Fifty shades of gray, Book 2"
;;     "Fifty shades of gray, Book 3")
#+end_src

There are 20 authors that write the books in the series.
After finising the first book, the first author writes the 21st book in the series, and so on.

Lets make the book titles
#+begin_src clojure
(def numbers (iterate inc 1))
;; => #'user/numbers
(def titles (map #(str "Fifty shades of gray, Book " %) numbers))
;; => #'user/titles
#+end_src

Lets make the authors
#+begin_src clojure
(def first-names ["Bob" "Jane" "Chuck" "Leo"])
;; => #'user/first-names
(def last-names ["Jordan" "Austen" "Dickens" "Tolstoy" "Poe"])
;; => #'user/last-names

;; There will be (* 4 5) = 20 authors
(defn combine-names [fname lname] (str fname " " lname))
;; => #'user/combine-names

(def authors (map combine-names (cycle first-names) (cycle last-names)))
;; => #'user/authors
#+end_src

Make the map of books
#+begin_src clojure
(defn make-book [title author] {:title title :author author})
;; => #'user/make-book
(def test-books (map make-book titles authors))
;; => #'user/test-books
#+end_src

Whenever ~(first test-books)~ is called, it triggers a cascade of computation.
But, the key is that we only compute just-in-time. Hence, we *only* pay for *both* the CPU and Memory that we actually use.

** Behind the Scenes
how to create a lazy sequence
#+begin_src clojure
(lazy-seq [1 2 3])
;; => (1 2 3)
#+end_src

~lazy-seq~ vs ~seq~
#+begin_src clojure
(defn chatty-vector []
  (println "I return a chatty vector")
  [1 2 3])
;; => #'user/chatty-vector

(def s1 (seq (chatty-vector)))          ;prints

(def s2 (lazy-seq (chatty-vector)))
(first s2)                              ;now prints
#+end_src

In Chapter 20, we will learn that ~lazy-seq~ is implemented using some macro magic.
-------------------------------------------------------------------------------------------------------------------------
How lazy sequence creation operations internally work:-

My own version of /repeat, iterate, map/
#+begin_src clojure
(defn my-repeat [x]
  (cons x (lazy-seq (my-repeat x))))
;; => #'user/my-repeat

(defn my-iterate [f x]
  (cons (f x) (lazy-seq (my-iterate f (f x)))))
;; => #'user/my-iterate
#+end_src

~my-map~ will also teach me how to terminate when one of the args is not infinite.
Its implementation also uses the idea that you can ~cons~ onto ~nil~
#+begin_src clojure
(cons 3.14 nil)
;; => (3.14)

;;;;below wont work for finite col
;;(defn my-map [f col]
;;  (cons (f (first col))
;;    (lazy-seq (my-map f (next col)))))

(defn my-map [f col]
  (when col
    (cons (f (first col))
      (lazy-seq (my-map f (next col))))))
;; => #'user/my-map
#+end_src

** Staying Out of Trouble
Helpful to avoid printing infintely long seqs
#+begin_src clojure
(set! *print-length* 20)
#+end_src
---------------------------------------------------------------------------------------------------
Aside:-
~slurp~ :- Universal Clojure tool to read something. Accepts url, filepath etc
~spit~ :- Write string to file path

#+begin_src clojure
(slurp "authors.txt")
#+end_src

#+begin_src clojure
(spit "/tmp/spit-out.txt" "Abrakadabra")
#+end_src
---------------------------------------------------------------------------------------------------
Be careful about side-effects when dealing with lazy sequences.
Take into consideration the state when the lazy sequence is finally evaluated, not at creation time of that sequence.

Use ~doall~ to force evaluation of a lazy seq right NOW.
~doseq~ is similar, and useful when you dont-want/space-wont-permit to hold a reference to the entire unlazified-sequence

** In the wild
nREPL
^Show a nice *Clojure design pattern0* to turn a *side-effect driven event* into a /lazy-seq/
Further processing is now easy. Because Clojure has a rich library of seq builtins.

?Visualize above design pattern:-
Look at ".model a stream of side effects as a lazy seq.svg" file in the current folder.

Bug:-
[//[file:.model a stream of side effects as a lazy seq.svg]//] hangs emacs! (if you uncomment it and enable inline images)
Hence, wasnt able to display above xopp file using ~org-xournal-redisplay-images~
The svg file isnt corrupted, because it opens properly in Google Chrome.

Workaround:- Manually exported to png and inserted below
[[file:model a stream of side effects as a lazy seq.png]]

Lazy sequences are /very very/ common in Clojure.
Only a few exceptions are not-lazy aka eager:- ~count~

* Destructuring
aka How to pluck just the value we need from some collection.

** Pry Open your Data
#+begin_src clojure
(def artists [:monet :austen])
;; => #'user/artists
(let [[painter novelist] artists]
  (println (str "The painter is: " painter))
  (println (str "The novelist is: " novelist)))
#+end_src

** Getting Less than Everything
#+begin_src clojure
(def artists [:monet :austen :beethoven :kuvempu])
;; => #'user/artists
(let [[painter novelist musician] artists]
  (println (str painter " // " novelist " // " musician)))
#+end_src

Ignoring some leading values
#+begin_src clojure
(let [[_ _ musician poet] artists]
  (println (str musician " // " poet)))
;;There is nothing special about '_', its just a convention
;;As usual, _ gets bound to :monet, then gets rebound to :austen, which is its value in the let body, but is unused
#+end_src

Two-level vector's destructuring
#+begin_src clojure
(def pairs [[:monet :austen] [:beethoven :dickinson]])
;; => #'user/pairs
(let [[[painter] [musician _]] pairs]   ;;The first braket need not compulsorily be [painter _]
  (println (str painter " // " musician)))
#+end_src

** Destructuring in Sequence
Same syntax as vector destructuring, *continue to use square brackets around the capturing template* 
#+begin_src clojure
(def artist-list '(:monet :austen :beethoven :dickinson))
;; => #'user/artist-list
(let [[painter novelist musician] artist-list]
  (println (str painter " // " novelist " // " musician)))
#+end_src
Those square brackets stand for /delimiters for ANY sequential data type/. (but we use flower bracket for map destructuring template)

Eg: String is a seq type. Therefore its characters can be destructured:-
#+begin_src clojure
(let [[c1 c2 c3 c4] "Anup"]
  (println (str "My name is spelled as:"))
  (println c1)
  (println c2)
  (println c3)
  (println c4))
#+end_src

The rule is, if you can turn it into a sequence, you can destructure it.

** Destructuring Function Arguments
#+begin_src clojure
(defn artist-description [[novelist poet]]
  (str "The novelist is: " novelist " and the poet is: " poet))
;; => #'user/artist-description
(artist-description [:austen :kuvempu])
;; => "The novelist is: :austen and the poet is: :kuvempu"
#+end_src
Just keep in mind that the value to be destructured *is provided when the function is called*

Mix and match normal function arguments with destructured arguments
#+begin_src clojure
(defn artist-description [shout [novelist poet]]
  (let [msg (str "The novelist is: " novelist " and the poet is: " poet)]
    (if shout
      (.toUpperCase msg)
      msg)))
;; => #'user/artist-description
(artist-description true [:austen :kuvempu])
;; => "THE NOVELIST IS: :AUSTEN AND THE POET IS: :KUVEMPU"
#+end_src

** Digging into Maps
*The ordering in the soaking-template is counter-intuitive.*
Instead of key, then value_soaker
The ordering is value_soaker, then key
#+begin_src clojure
(def artist-map {:painter :monet :novelist :austen})
;; => #'user/artist-map
(let [{painter :painter novelist :novelist} artist-map]
  (println (str painter " // " novelist)))
;; => nil
#+end_src

Doubt: We know that
SICP taught me that ~let~ is just syntactic sugar for a lambda definition and that lambda being called
Can this explain the counter intuitive ordering?

** Diving into Nested Maps
#+begin_src clojure
(def austen {:name "Jane Austen" :parents {:father "George" :mother "Cassandra"} :dates {:born 1775 :died 1817}})
;; => #'user/austen
(let [{{father :father mother :mother} :parents} austen]
  (str "Her father was " father " and mother was " mother))
;; => "Her father was George and mother was Cassandra"

(let [{name :name
       {mother :mother} :parents
       {dob :born} :dates} austen]
  (str name " was born in " dob " and her mother's name was " mother))
;; => "Jane Austen was born in 1775 and her mother's name was Cassandra"
#+end_src

** The final frontier: Mixing and Matching
Eg1
#+begin_src clojure
(def author {:name "Jane Austen"
             :books [{:title "Sense and Sensibility" :published 1811}
                     {:title "Emma" :published 1815}]})
;; => #'user/author
(let [{name :name
       [book] :books} author]
  (str "The author is " name " and one of their books is " book))
;; => "The author is Jane Austen and one of their books is {:title \"Sense and Sensibility\", :published 1811}"
#+end_src

Eg2
#+begin_src clojure
(def authors [{:name "Jane Austen" :born 1775}
              {:name "Charles Dickens" :born 1812}])
;; => #'user/authors
(let [[{dob1 :born} {dob2 :born}] authors]
  (str "One author was born in " dob1 " and the other author was born in " dob2))
;; => "One author was born in 1775 and the other author was born in 1812"
#+end_src

** Going further
In this section we learn two more tricks:-

1. How to automatically make the key_name as the capturing name
   #+begin_src clojure
   (def character {:name "Mario" :age 16 :gender :male})
   ;; => #'user/character

   (defn character-desc [{name :name age :age gender :gender}]
     (str "Name: " name " Age: " age " Gender: " gender))
   ;; => #'user/character-desc

   (defn character-desc [{:keys [name age gender]}]
     (str "Name: " name " Age: " age " Gender: " gender))
   ;; => #'user/character-desc

   (character-desc character)
   ;; => "Name: Mario Age: 16 Gender: :male"
   #+end_src
Notice that ordering of =:keys= and =[name age gender]= is counter-intuitive.
This reversal, ie, a keyword on the left side,
lets the destructuring mechanism to treat this as a special case.

Just remember the capture template syntax ~:keys [keyword_without_left_colon_1    keyword_without_left_colon_2 ...]~
---------------------------------------------------------------------------------------------------

Mix and match normal destructuring with /:keys based destructuring/
#+begin_src clojure
(defn character-desc [{:keys [name gender]
                       age-in-years :age}]
  (str "Name: " name " age:" age-in-years " gender: " gender))
;; => #'user/character-desc
(character-desc character)
;; => "Name: Mario age:16 gender: :male"
#+end_src

   ---------------------------------------------------------------------------------------------------
2. How to capture the *both* the un-destructured whole along with some destructured from it.

Lets say we want to add a new key called ~:greeting~ into the above character of map type

To bulid the ret by +consing+ /assoc-ing/, we need the original map
But to build the value of greeting, we need the destructured name, age, gender

So, we need to capture both
#+begin_src clojure
(defn add-greeting [{:keys [name age] :as character}]
  (assoc character
    :greeting (str "Hello, my name is " name " and I am " age " years old.")))
;; => #'user/add-greeting
(add-greeting character)
;; => {:name "Mario",
;;     :age 16,
;;     :gender :male,
;;     :greeting "Hello, my name is Mario and I am 16 years old."}
#+end_src
Just remember the syntax ~:as character~ within  the flower brackets

** Staying out of trouble
Whenever you want to dive very deep:-
1. Drill down in *multiple stages, with descriptive intermediate names* (intention-revealing names)

Eg: Lets say we want to print the fullname of the second user's favorite author:-
#+begin_src clojure
(def user-info [{:name "Charlie", :fav-book {:title "Carrie", :author ["Stephen" "King"]}}
                {:name "Jennifer", :fav-book {:title "Emma", :author ["Jane" "Austen"]}}])
;; => #'user/user-info

;;BAD VERSION
;;full name of the author of the second reader's fav book
;;(defn format-a-name [[_
;;                      {{[first-name last-name] :author} :fav-book}]]
;;  (str first-name " " last-name))
;; => #'user/format-a-name

(format-a-name user-info)
;; => "Jane Austen"

;;GOOD VERSION
(defn format-a-name [[_ second-user]]
  (let [[first-name last-name] (->> second-user :fav-book :author)]
    (str first-name " " last-name)))
;; => #'user/format-a-name

(format-a-name user-info)
;; => "Jane Austen"
#+end_src
------------------------------------------------------------------------------------------------------------------------
2. Destructuring *only works inside* a ~let~ or inside a ~defn~
#+begin_src clojure
(def author {:name "Jane Austen" :born 1775})
;; => #'user/author

;;WONT WORK
;;(def author-name [{n :name} author])
#+end_src
ie, we cannot use the destructuring template followed by 'author' outside of the above two forms

A ~let~ can be used to make above work
#+begin_src clojure
(def author-name (let [{name :name} author] name))
;; => #'user/author-name
author-name
;; => "Jane Austen"
#+end_src

** In the wild
Korma SQL library
^We also learn ~:or~ which is a sister of ~:as~
~:or~ lets you set default values when destructuring fails due to absence of some key.
** Wrapping up
Destructuring is soo  much better than ~first~-ing , ~rest~-ing, nth-ing till your head explodes 😀
* Records and Protocols
Records are +like+ maps, but specialized for a particular purpose.

** Two troubles with Maps
1. any key with any value, this flexibility => slow cod
2. lack of coherence and documentation, Eg: A map name =watson= could be either of a fictional character or a supercomputer.

** How to create a Record
#+begin_src clojure
(defrecord FictionalCharacter [name appears-in author])
;; => user.FictionalCharacter
#+end_src
^This creates a record
and two functions that help create instances:-
~->FictionalCharacter~ & ~map->FictionalCharacter~
#+begin_src clojure
(def watson (->FictionalCharacter "John Watson" "Sherlock Holmes" "Doyle"))
;; => #'user/watson
#+end_src
Or, create from a map
#+begin_src clojure
(def elizebeth (map->FictionalCharacter {:name "Elizebeth Bennet" :appears-in "Pride & Prejudice" :author "Austen"}))
;; => #'user/elizebeth
#+end_src

** Records are Maps
All map functions still work on records:-
#+begin_src clojure
(:name elizebeth)
;; => "Elizebeth Bennet"
(count elizebeth)
;; => 3
(keys watson)
;; => (:name :appears-in :author)
#+end_src

You can modify records
#+begin_src clojure
(def specific-watson (assoc watson :appears-in "Bourge-villas"))
;; => #'user/specific-watson
specific-watson
;; => {:name "John Watson", :appears-in "Bourge-villas", :author "Doyle"}
#+end_src

Aside, Doubt? Why *doesnt* ~specific-watson~ print as =user.FictionalCharacter{:name "John Watson", :appears-in "Sherlock Holmes", :author "Doyle"}=

You can add /extra/ key value pair to a record
They dont get the speed benefit though.
#+begin_src clojure
(def more-about-watson (assoc watson :address "211B Baker Street"))
;; => #'user/more-about-watson
#+end_src

** Two advantages of Records
They fix the two disadvantages of maps.
1. faster
2. makes code clearer. ie, watson and watson2 are distinguishable

   #+begin_src clojure
   (defrecord SuperComputer [cpu no-cpus storage-gb])
   ;; => user.SuperComputer
   (def watson2 (->SuperComputer "Power7" 2880 4000))
   ;; => #'user/watson2

   (class watson)
   ;; => user.FictionalCharacter
   (class watson2)
   ;; => user.SuperComputer

   (instance? SuperComputer watson2)
   ;; => true
   #+end_src
BTW, ~class~ works on ALL values, not just records.
Doubt, how is ~(class~ different from ~(type~
---------------------------------------------------------------------------------------------------
*Important Aside*
*Dont do this*
#+begin_src clojure
;;never:-
(defn process-thing [x]
  (if (= (instance? FictionalCharacter x))
    (process-fictional-character x)
    (process-computer x)))
#+end_src
^above will surely lead to spaghetti code. (Aside: Does Lit-Knuth agree with this?)
*Clojure's way of dealing with such type sensitive code is using Protocols*

** Protocols
#+begin_src clojure
(defrecord Employee [first-name last-name department])
;; => user.Employee
(def alice (->Employee "Alice" "Smith" "Engineering"))
;; => #'user/alice
#+end_src

Both =watson= and =alice= have a name.

How can we treat both of them as people? Enter Protocols:-
Make both of them implement the Person protocol.

#+begin_src clojure
(defprotocol Person
  (full-name [this])
  (greeting [this msg])
  (description [this]))
;; => Person
#+end_src
^Defines a protocol and  also creates *3 polymorphic functions*

Aside:- Polymorphic fn = what they do depends on the type of their *first* argument

Make both of them implement the Person protocol
ie define the /methods/
#+begin_src clojure
(defrecord FictionalCharacter [name appears-in author]
  Person
  (full-name [this] (:name this))
  (greeting [this msg] (str msg " " (:name this)))
  (description [this] (str (:name this) " is a character in " (:appears-in this))))
;; => user.FictionalCharacter

(defrecord Employee [first-name last-name department]
  Person
  (full-name [this] (str first-name " " last-name))
  (greeting [this msg] (str msg " " (:first-name this)))
  (description [this] (str (:first-name this) " works in " (:department this))))
;; => user.Employee
#+end_src

Lets create instances and try them all out:-
#+begin_src clojure
(def sofia (->Employee "Sofia" "Diego" "Finance"))
;; => #'user/sofia
(def sonny (->FictionalCharacter "Sonny Corleone" "The Godfather" "Puzo"))
;; => #'user/sonny

(full-name sofia)
;; => "Sofia Diego"
(full-name sonny)
;; => "Sonny Corleone"

(greeting sofia "Sayonara, ")
;; => "Sayonara,  Sofia"
(greeting sonny "Sayonara, ")
;; => "Sayonara,  Sonny Corleone"

(description sofia)
;; => "Sofia works in Finance"
(description sonny)
;; => "Sonny Corleone is a character in The Godfather"
#+end_src

** Decentralized Polymorphism using ~extend-protocol~
After you make a new protocol,
#+begin_src clojure
(defprotocol Marketable
  (make-slogan [this]))
;; => Marketable
#+end_src

you can extend *already defined* records to conform to this new protocol. Without touching their original definitions. Hence decentralized.

Lets say we want to add a 'Marketing slogan' to each of our already defined Employee, FictionalCharacter and SuperComputer
#+begin_src clojure
(extend-protocol Marketable
  Employee (make-slogan [e] (str (:first-name e) "is the BEST employee!"))
  FictionalCharacter (make-slogan [fc] (str (:name fc) " is the GREATEST character!"))
  SuperComputer (make-slogan [sc] (str "This computer has " (:no-cpus sc) " CPUs!")))
;; => nil
#+end_src

You can even make data types that arent records to follow your protocol
#+begin_src clojure
(extend-protocol Marketable
  String (make-slogan [s] (str \" s \" " is a string! WOW!"))
  Boolean (make-slogan [b] (str b " is one of the two surviving Booleans!")))
;; => nil
#+end_src

#+begin_src clojure
(make-slogan sonny)
;; => "Sonny Corleone is the GREATEST character!"
(make-slogan true)
;; => "true is one of the two surviving Booleans!"
#+end_src

ie Records and Protocols are decoupled
they are independent of each other in time and ?space

** Records-Protocols vs OOP
Analogy/Resemblance:-
Records ~ Classes
Record instances ~ Objects
Protocols ~ Abstract Interfaces

Protocols are Clojure's riff on type-based polymorphism
(Type-based polymorphism definition - the idea that you can have a single operation implemented in different ways by different types.)

*But* differences:-
Unlike objects, Record instances are immutable
Unlike classes, Records have no concept of inheritance. ie there are no Super Record types.

*Many significant Clojure programs dont feel the necessity for records and protocols*
Therefore, *avoid premature usage of records and protocols, just use simple maps & functions*

** Protocols vs Multimethods
/One Similarity:-/
both of them let you express Polymorphism

/Two differences:-/
Multimethods can branch out (dispatch) based on *any* criterion, not just /type/
Protocols always branch out based on /type/

Multimethods define a single operation
Protocols refer to a collection of operations.

/One Usage tip:-/
Multimethod is a more generic concept than Protocols.
Design choice: If Protocol suffices, avoid using a multimethod in its place.

** In the wild
Clostache templating library
*Clostache library uses just ONE record type. It uses NO protocols, NO polymorphism. Its just simple maps and functions. This is typical of Clojure projects.*
It has 318 stars, ?but is widely used.

Stuart Sierra's Component library
*It uses just ONE protocol*
It has 2.1k stars, and is the most used library for startup management.

~reify~ creates a one-off protocol-instance without defining a protocol. Its helpful for testing purposes.
Such instances are permitted to implement a protocol partially. ie, omit some methods.

** Staying out of trouble
*** Records
When using ~(map->SomeRecord some_map)~, if you mis-name a key of its argument,
that key-value pair will end up as an *extra key-value*. This missed key's value will be set to nil.
tldr: carefully match argument keys with defrecord slot names.
---------------------------------------------------------------------------------------------------
Botched ~assoc~ due to similar mis-name of key will, similarly,
result in an *extra key-value pair* and a nil-led pair.
*** Protocols
~defprotocol~ adds functions to the namespace. Be careful of function-name collisions with builtin functions.

Two ~defprotocols~ might add function names that might collide with each other's.

When in doubt, put each protocol in its own namespace.

---------------------------------------------------------------------------------------------------
Records have a more generic cousin0 named Types
~deftype~
A Record comes with a map and fast access etc.
Whereas, a 'type' is more of a blank slate.

*Types are almost never used in Clojure*
** Wrapping up
Records are specialized maps.
Protocols are collection of functions, that can be used to define *polymorphic operatons /on/ records*
* Tests
Tests make sure your code works.

Eg: We have an inventory of books. We want to write two functions.

1. find book-x by title
2. find number of copies of a book-x
where book-x is one of the books from the inventory.

We learn =clojure.test= and =clojure.check= by setting up tests for the above two.

** clojure.test
~lein new inventory~

What inventory looks like:-
#+begin_src clojure
[{:title "2001" :author "Clarke" :copies 21}
 {:title "Emma" :author "Austen" :copies 10}
 {:title "Misery" :author "King" :copies 101}]
#+end_src

#+begin_src clojure :tangle ./inventory/src/inventory/core.clj
(ns inventory.core)

(defn find-by-title
  "Search for a book by title, where title is a string and books is a collection of book maps, each of which must have a :title entry"
  [title books]
  (some #(if (= (:title %) title) %) books)) ;;Recall that the ~some~ returns whatever the first truthy predicate returns 
;; => #'user/find-by-title

(defn number-of-copies-of
  "Return the number of copies in inventory of the given title, where title is a string and books is a collection of book maps each of which must have a :title entry"
  [title books]
  (:copies (find-by-title title books)))
;; => #'user/number-of-copies-of
#+end_src
Also, by convention, Clojure orders the function arguments such that,
collection is the last argument.
*** Where should I put my tests?
The convention is to put them in a 'parallel' module; and suffix a =-test= to the end of the namespace. (Recall that =-= becomes =_= for filenames)
Whats parallel:-
=./inventory/src/inventory/core.clj=
Parallel to it is
=./inventory/test/inventory/core_test.clj=

~(ns inventory.core)~
Suffixing it is
~(ns inventory.core-test)~
*** ~deftest~
~deftest~ lets us wire up the test
#+begin_src clojure :tangle ./inventory/test/inventory/core_test.clj
(ns inventory.core-test
  (:require [clojure.test :refer :all])
  (:require [inventory.core :as i]))

(def books [{:title "2001" :author "Clarke" :copies 21}
            {:title "Emma" :author "Austen" :copies 10}
            {:title "Misery" :author "King" :copies 101}])

(deftest test-finding-books
  (is (not (nil? (i/find-by-title "Emma" books)))))

;;(deftest test-something-that-fails
;;  (is (not (nil? (i/find-by-title "Bla Bla Blue" books)))))

;;can include more than one condition inside a single deftest
(deftest test-finding-books-better
  (is (not (nil? (i/find-by-title "Emma" books))))
  (is (nil? (i/find-by-title "Bla Bla Blue" books))))

;;organise tests into subtests using ~(testing~
(deftest test-basic-inventory
  (testing "Finding books"
    (is (not (nil? (i/find-by-title "Emma" books))))
    (is (nil? (i/find-by-title "Bla Bla Blue" books))))
  (testing "Copies in inventory"
    (is (= 10 (i/number-of-copies-of "Emma" books)))))
#+end_src
^Notice that since unit-tests are argumentless predicates, ~deftest~ syntax doesnt have any argument list.

A =dev= directory is conventionally used to store REPL commands etc
#+begin_src bash :results output verbatim :dir ./inventory
mkdir dev
#+end_src

#+RESULTS:

Run those tests
#+begin_src clojure :tangle ./inventory/dev/run_test.clj
(require '[inventory.core-test :as ct])

(ct/test-finding-books)
#+end_src
** Run all the tests
~(clojure.test/run-tests ...~
#+begin_src clojure :tangle ./inventory/dev/run_tests.clj
(require 'inventory.core-test)          ;?because tests arent loaded by default in a lein repl
(require 'clojure.test)

(ns inventory.core-test)                     ;select this ns
(clojure.test/run-tests)                ;runs all tests in current ns
(clojure.test/run-tests *ns*)

;;below can be run from any namespace
(clojure.test/run-tests 'inventory.core-test)
#+end_src

Using =lein=
#+begin_src bash :results output verbatim :dir ./inventory
lein test
#+end_src

#+RESULTS:
: 
: lein test inventory.core-test
: 
: Ran 3 tests containing 6 assertions.
: 0 failures, 0 errors.
** Generative Property based testing
Programmatically generate test cases.

External library name is ~test.check~
Add ~[org.clojure/test.check "1.1.1"]~ to =project.clj=

~sample~ is hardcoded to return next 10 values from a generator
#+begin_src clojure :noweb-ref "Define the generator"
(require '[clojure.test.check.generators :as gen])
(gen/sample gen/string-alphanumeric)
#+end_src

#+begin_quote output
inventory.core> (gen/sample gen/string-alphanumeric)
("" "" "" "83" "L5" "9" "" "uErvu1" "R8Gc6eN" "A2h")
#+end_quote

To make =C-x C-e= work:-
Start a cider repl inside the =inventory= folder
Then connect to it using =M-x cider-connect= , pick localhost.

We can get rid of empty string using ~gen/such-that~ that accepts a /predicate/ checker
#+begin_src clojure :noweb-ref "Define the generator"
(def title-gen (gen/such-that not-empty gen/string-alphanumeric))
;; => #'inventory.core/title-gen
(def author-gen (gen/such-that not-empty gen/string-alphanumeric))
;; => #'inventory.core/author-gen
(def copies-gen (gen/such-that (complement zero?) gen/pos-int))
;; => #'inventory.core/copies-gen
#+end_src

Above generators can be combined
#+begin_src clojure :noweb-ref "Define the generator"
;;lets build a book generator
(def book-gen
  (gen/hash-map :title title-gen :author author-gen :copies copies-gen))
;; => #'inventory.core/book-gen
#+end_src

Try it out
#+begin_src clojure
(gen/sample book-gen)
;; => ({:title "Q", :author "m0", :copies 2}
;;     {:title "U9", :author "b", :copies 1}
;;     {:title "7", :author "zC", :copies 1}
;;     {:title "h", :author "wM3", :copies 1}
;;     {:title "xu", :author "67w", :copies 3}
;;     {:title "pSK", :author "1zy2g", :copies 1}
;;     {:title "6bNV", :author "WNkS", :copies 2}
;;     {:title "vlr488q", :author "TeC", :copies 8}
;;     {:title "V9", :author "eiwf05Mn", :copies 6}
;;     {:title "W7vQUGgy", :author "R1", :copies 7})
#+end_src

~gen/vector~ spits out a vector whose elements are chosen from generator
#+begin_src clojure
(gen/sample (gen/vector book-gen))
;; => ([]
;;     []
;;     [{:title "p", :author "0t", :copies 2}]
;;     [{:title "Q", :author "Flm", :copies 1}]
;;     [{:title "27Y", :author "Fzu", :copies 3}
;;      {:title "k47", :author "dm", :copies 4}
;;      {:title "G", :author "6X3", :copies 2}
;;      {:title "zEvh", :author "hj37", :copies 4}]
;;     [{:title "M4ML", :author "4Y6", :copies 3}]
;;     [{:title "VoQGop", :author "j2", :copies 1}
;;      {:title "6J", :author "6KIJ", :copies 1}
;;      {:title "3", :author "q3Z", :copies 3}
;;      {:title "S6", :author "b438L", :copies 3}
;;      {:title "E3CAC2", :author "s0F7T6", :copies 5}
;;      {:title "eI", :author "516", :copies 2}]
;;     [{:title "Lzvk", :author "81Z3", :copies 2}
;;      {:title "K", :author "1AhmIc9", :copies 7}
;;      {:title "vmu5", :author "I", :copies 3}
;;      {:title "uY1", :author "e953", :copies 4}
;;      {:title "sJ81Dg1", :author "24CA8", :copies 5}
;;      {:title "569Qu", :author "73q", :copies 7}]
;;     [{:title "5", :author "9L7Cn0k", :copies 4}
;;      {:title "W7e53u", :author "WF85", :copies 8}
;;      {:title "9", :author "355fT", :copies 3}
;;      {:title "37QW3", :author "g2ifC", :copies 7}]
;;     [{:title "195HHa", :author "9", :copies 7}
;;      {:title "m", :author "4j583P6qy9", :copies 3}
;;      {:title "MNqIwA3", :author "7o5", :copies 7}
;;      {:title "Q7rH9s7", :author "k9t1", :copies 1}
;;      {:title "L", :author "N1362h", :copies 6}
;;      {:title "yS1eNG", :author "0xC00jud", :copies 1}])
#+end_src

Lets get rid of empty vectors, aka, empty inventories
#+begin_src clojure
(gen/sample (gen/such-that not-empty (gen/vector book-gen)))
;; => ([{:title "p2", :author "9d", :copies 1}]
;;     [{:title "tLt4", :author "329", :copies 1}]
;;     [{:title "I", :author "q8dQ", :copies 3}]
;;     [{:title "5", :author "5V", :copies 1}]
;;     [{:title "9eq", :author "00r4m", :copies 3}
;;      {:title "I", :author "H6", :copies 6}]
;;     [{:title "p", :author "0", :copies 2}]
;;     [{:title "m628", :author "9qx", :copies 1}
;;      {:title "s7h60pP", :author "Hp", :copies 2}
;;      {:title "0V", :author "44me", :copies 6}]
;;     [{:title "C1vs8H", :author "S7", :copies 1}
;;      {:title "34p8G", :author "3hg", :copies 1}]
;;     [{:title "948pp", :author "ZId2", :copies 4}
;;      {:title "wCz7W", :author "0", :copies 6}
;;      {:title "SLN42EdLI5", :author "iBLp", :copies 1}
;;      {:title "1", :author "4VwE7", :copies 7}
;;      {:title "7", :author "Ildxd1j5", :copies 7}
;;      {:title "27n11", :author "81o1dw", :copies 3}
;;      {:title "Sq1Ys2tG", :author "VbobU8H", :copies 8}
;;      {:title "0jd", :author "5", :copies 6}]
;;     [{:title "5j", :author "ga63AME", :copies 2}
;;      {:title "CE", :author "6", :copies 9}
;;      {:title "7", :author "wBP", :copies 3}])
#+end_src

~(gen/not-empty~ does the same as ~(gen/such-that not-empty~
#+begin_src clojure :noweb-ref "Define the generator"
(def inventory-gen (gen/not-empty (gen/vector book-gen)))
;; => #'inventory.core/inventory-gen
#+end_src

Aside doubt: Are all simple Clojure maps implemented as hashmaps?

Think again about what one testcase consists of:-
- An inventory of books
- One book from amongst them
  
To test our two functions,
We also need a single book from each of the generated inventories.
aka, we want to pluck a book from the inventory
This can be done using ~gen/elements~
#+begin_src clojure
(gen/let [inventory inventory-gen
          book (gen/elements inventory)]
  {:inventory inventory :book book})
;; => {:gen #function[clojure.test.check.generators/gen-bind/fn--5190]}
#+end_src

Lets bind it
#+begin_src clojure :noweb-ref "Define the generator"
(def inventory-and-book-gen (gen/let [inventory inventory-gen
                                      book (gen/elements inventory)]
                              {:inventory inventory :book book}))
;; => #'inventory.core/inventory-and-book-gen
#+end_src

Try it
#+begin_src clojure
(gen/sample inventory-and-book-gen)
;; => ({:inventory [{:title "7", :author "s", :copies 1}],
;;      :book {:title "7", :author "s", :copies 1}}
;;     {:inventory [{:title "u", :author "y", :copies 3}],
;;      :book {:title "u", :author "y", :copies 3}}
;;     {:inventory
;;      [{:title "j", :author "Np", :copies 2}
;;       {:title "mv", :author "7u", :copies 2}],
;;      :book {:title "j", :author "Np", :copies 2}}
;;     {:inventory
;;      [{:title "g67", :author "2G5L", :copies 1}
;;       {:title "2o1", :author "qvj", :copies 3}
;;       {:title "Ej3", :author "y1", :copies 4}],
;;      :book {:title "Ej3", :author "y1", :copies 4}}
;;     {:inventory [{:title "a", :author "0h", :copies 3}],
;;      :book {:title "a", :author "0h", :copies 3}}
;;     {:inventory
;;      [{:title "d", :author "Qlauo", :copies 5}
;;       {:title "C8xMx", :author "6Z3", :copies 1}
;;       {:title "SG", :author "lLb", :copies 5}],
;;      :book {:title "SG", :author "lLb", :copies 5}}
;;     {:inventory [{:title "sB", :author "xoQFL3P8", :copies 7}],
;;      :book {:title "sB", :author "xoQFL3P8", :copies 7}}
;;     {:inventory
;;      [{:title "0oril", :author "hi7KX", :copies 5}
;;       {:title "9C", :author "N1LqU", :copies 6}
;;       {:title "ONg8", :author "wsMtv8v", :copies 1}
;;       {:title "osN4333", :author "2VE", :copies 3}
;;       {:title "t3", :author "VY", :copies 7}],
;;      :book {:title "t3", :author "VY", :copies 7}}
;;     {:inventory
;;      [{:title "U47d3I40r", :author "li", :copies 7}
;;       {:title "Lu2q2L4yC", :author "a", :copies 4}
;;       {:title "Nys1Xa8J", :author "PY85", :copies 8}
;;       {:title "zucCZ7p", :author "51t0uJvo", :copies 6}
;;       {:title "E97O", :author "3", :copies 1}
;;       {:title "8OH", :author "dvcX", :copies 7}
;;       {:title "hQnfo1rs0", :author "AysSC8CK7", :copies 4}],
;;      :book {:title "Nys1Xa8J", :author "PY85", :copies 8}}
;;     {:inventory
;;      [{:title "GVD1", :author "gbzb", :copies 1}
;;       {:title "J1VYKsX", :author "SuImD", :copies 5}
;;       {:title "Pg03A9vX6", :author "jYh9x8WU1", :copies 5}
;;       {:title "4r8E8", :author "05PCga3", :copies 7}
;;       {:title "DQ", :author "bsz7br8", :copies 10}],
;;      :book {:title "4r8E8", :author "05PCga3", :copies 7}})
#+end_src

Now, we have completed generating the data for testing.
** Checking Properties - aka Running Generated Testcases
Aside: The author has more or less plagiarized [[https://clojure.github.io/test.check/intro.html][Introduction to test.check]]

Let us take two toy examples to understand /expressing the property/ to be tested

Each positive integer is smaller than the next positive integer
#+begin_src clojure
(require :reload '[clojure.test.check.properties :as prop])
;; => nil
#+end_src

Lets express the property.

Let us wire up an infinite number of testcases
#+begin_src clojure
(prop/for-all [i gen/pos-int]
  (< i (inc i)))
;; => {:gen #function[clojure.test.check.generators/gen-fmap/fn--5185]}
#+end_src

Lets limit the infinite number of cases to say 50
~clojure.test.check/quick-check~ will randomly pick 50

#+begin_src clojure
(require :reload '[clojure.test.check :as tc])
;; => nil
#+end_src

#+begin_src clojure
(tc/quick-check 50
  (prop/for-all [i gen/pos-int]
    (< i (inc i))))
;; => {:result true,
;;     :pass? true,
;;     :num-tests 50,
;;     :time-elapsed-ms 1,
;;     :seed 1723931317348}
#+end_src
---------------------------------------------------------------------------------------------------
Let us apply what we learnt to check our book inventory:-
#+begin_src clojure
(require '[clojure.test.check.properties :as prop])
(require '[clojure.test.check :as tc])
(require '[inventory.core :as i])

(tc/quick-check 50
  (prop/for-all [i-and-b inventory-and-book-gen]
    (= (i/find-by-title (->> i-and-b :book :title) (->> i-and-b :inventory))
      (:book i-and-b))))
;; => {:result true,
;;     :pass? true,
;;     :num-tests 50,
;;     :time-elapsed-ms 71,
;;     :seed 1723931998480}
#+end_src

Aside:- Below is valid too, because maps themselves are functions too
#+begin_src clojure
(tc/quick-check 50
  (prop/for-all [i-and-b inventory-and-book-gen]
    (= (i/find-by-title (-> i-and-b :book :title) (-> i-and-b :inventory))
      (:book i-and-b))))
;; => {:result true,
;;     :pass? true,
;;     :num-tests 50,
;;     :time-elapsed-ms 63,
;;     :seed 1723932041896}
#+end_src

If need be, we can integrate the above tests with clojure.test
#+begin_src clojure :tangle ./inventory/test/inventory/core_gen_test.clj
(ns inventory.core-gen-test)

(require :reload '[clojure.test.check.properties :as prop])
(require :reload '[clojure.test.check :as tc])
(require :reload '[inventory.core :as i])
(require :reload '[clojure.test.check.clojure-test :as ctest])

<<Define the generator>>

(ctest/defspec find-by-title-finds-books 50
  (prop/for-all [i-and-b inventory-and-book-gen]
    (= (i/find-by-title (->> i-and-b :book :title) (->> i-and-b :inventory))
      (:book i-and-b))))
#+end_src

Run it
#+begin_src clojure
(find-by-title-finds-books)
;; => {:result true,
;;     :pass? true,
;;     :num-tests 50,
;;     :time-elapsed-ms 75,
;;     :seed 1723985591822}
#+end_src


As ususal =lein test= will run all =clojure.test= in all namespaces.
** In the wild

[[file:clojure/test/clojure/test_clojure/numbers.clj::(deftest test-add]]
[[file:clojure/test/clojure/test_clojure/sequences.clj::(deftest test-cons]]

~and~ is useful to build parameterized tests. Its a sister of ~(is~

* Spec
Clojure is more concerned with the shape of the data than its type.

** ~clojure.spec/valid?~,  ~clojure.spec/or~,  ~clojure.spec/and~

=clojure.spec= is a library  for verifying the shape of data.
its kinda like a regular expression library for clojure data.

#+begin_src clojure
(ns inventory.core
  (:require [clojure.spec.alpha :as s]))
#+end_src
^Above library comes bundled with Clojure language.

#+begin_src clojure
(s/valid? number? 44)
;; => true
(s/valid? number? :somekeyword)
;; => false
#+end_src
~s/valid?~ accepts a predicate function
We call those predicate functions as /a spec/

~s/and~ and ~s/or~ helps build such predicate functions.

=n= stands for =number=, not =not=
#+begin_src clojure
(def n-gt-10 (s/and number? #(> % 10)))
;; => #'inventory.core/n-gt-10

(s/valid? n-gt-10 1)
;; => false
(s/valid? n-gt-10 10)
;; => false
(s/valid? n-gt-10 11)
;; => true
#+end_src
~n-gt-10~ is /a spec/

#+begin_src clojure
(def n-gt-10-lt-100 (s/and number? #(> % 10) #(< % 100)))
;; => #'inventory.core/num-gt-10-lt-100
(s/valid? n-gt-10-lt-100 55)
;; => true
#+end_src

*The argument list to ~s/or~ has a twist*
#+begin_src clojure
;;wrong:-
;;(def num-or-str (s/or number? string?))

(def n-or-s (s/or :a-number number? :a-string string?))
;; => #'inventory.core/num-or-str
(s/valid? n-or-s "Hello")
;; => true
(s/valid? n-or-s 99)
;; => true
(s/valid? n-or-s true)
;; => false
#+end_src
The keywords are required to give descriptive feedback whenever a spec fails.
We call this as a spec with /descriptive keywords/

~s/and~ and ~s/or~ accepts either of
normal predicates or other specs.
#+begin_src clojure
(def n-gt-10-or-symbol (s/or :greater-10 n-gt-10 :a-symbol symbol?))
#+end_src

** Spec-ing collections
#+begin_src clojure
(def coll-of-strings (s/coll-of string?))
;; => #'inventory.core/coll-of-strings
(def coll-of-n-or-s (s/coll-of n-or-s))
;; => #'inventory.core/coll-of-n-or-s
#+end_src

~s/cat~ helps build specs that say /this should follow that/ in a collection.
Doubt:- Why is it named so?

Four element collections of the form:- string, number, string, number
#+begin_src clojure
(def s-n-s-n (s/cat :s1 string? :n1 number? :s2 string? :n2 number?))
;; => #'inventory.core/s-n-s-n
(s/valid? s-n-s-n ["Emma" 1815 "Jaws" 1974])
;; => true
#+end_src
---------------------------------------------------------------------------------------------------
*** Specs for maps, for key existence:-
#+begin_src clojure
;;define the book spec
(def book-s
  (s/keys :req-un [:inventory.core/title
                   :inventory.core/author
                   :inventory.core/copies]))
;; => #'inventory.core/book-s
(s/valid? book-s {:title "Emma" :author "Austen" :copies 10})
;; => true
(s/valid? book-s {:title "Arabian Nights" :copies 17})
;; => false

;;additional keys are permitted
(s/valid? book-s {:title "Emma" :author "Austen" :copies 10 :published 1968})
;; => true
#+end_src

=:req-un= :-
'-un' stands for unqualified keywords.
ie We suppy qualified keywords to ~s/keys~ function, and ask it to look for unqualified keywords in the map.

*** Why are fully qualified keywords used to define map specs?
Specs are meant to be [[*Registering Specs][registered]] to a global registry.
This means, we need to use fully qualified keynames.
If not, there could be collisions in keywords.

** Registering Specs
After registering to a JVM wide registry, any code can use my specs.
=clojure.spec/def= does the registration into the /global registry/
(not to be confused with ~def!~)

A spec is registered at a 'keyword'
#+begin_src clojure
(s/def :inventory.core/book
  (s/keys :req-un [:inventory.core/title
                   :inventory.core/author
                   :inventory.core/copies]))
;; => :inventory.core/book
#+end_src
Then on, you can use that keyword as a /spec/ globally
#+begin_src clojure
(s/valid? :inventory.core/book {:title "Dracula" :author "Stoker" :copies 10})
;; => true
#+end_src

Recall that =::= is a shorthand for the current namespace,
Therefore, above could also be re-written as:-
#+begin_src clojure
(s/def ::book
  (s/keys :req-un [::title
                   ::author
                   ::copies]))
;; => :inventory.core/book
#+end_src

However, above spec says nothing above the values associated with the keys in above map
#+begin_src clojure
(s/valid? ::book {:title 1234 :author false :copies "many"})
;; => true
#+end_src
^Lets fix this
** Specs for maps, for type of value:-

We have already defined a spec for =:inventory.core/book=
If we register a spec for each of the above map's keys,
then ~s/valid?~ will automatically also ensure that the map's values match the above specs.
#+begin_src clojure
(s/def ::title string?)
;; => :inventory.core/title
(s/def ::author string?)
;; => :inventory.core/author
(s/def ::copies number?)
;; => :inventory.core/copies
(s/def ::book (s/keys :req-un [::title ::author ::copies]))
;; => :inventory.core/book
#+end_src

#+begin_src clojure
(s/valid? ::book {:title 1234 :author false :copies "many"})
;; => false
(s/valid? ::book {:title "Dracula" :author "Stoker" :copies 10})
;; => true
#+end_src
** ~explain~-ing why a particular spec didnt match
Output happens by a printout
#+begin_src clojure :results output
(s/explain n-gt-10 1)
;; => nil
#+end_src

#+RESULTS:
: 1 - failed: (> % 10)

#+begin_src clojure :results output
(s/valid? ::book {:author :austen :title :emma})
;; => false
(s/explain ::book {:author :austen :title :emma})
;; => nil
#+end_src

#+RESULTS:
: :austen - failed: string? in: [:author] at: [:author] spec: :inventory.core/author
: :emma - failed: string? in: [:title] at: [:title] spec: :inventory.core/title
: {:author :austen, :title :emma} - failed: (contains? % :copies) spec: :inventory.core/book

---------------------------------------------------------------------------------------------------
~conform~ is a nice truthy function:-
If a spec fails, it returns the specific keyword =:clojure.spec.alpha/invalid=
#+begin_src clojure
(s/conform n-gt-10 1)
;; => :clojure.spec.alpha/invalid
#+end_src

If it matches, it returns the value itself for simple specs &
for specs with /descriptive keywords/
returns a map of 'spec descriptive' keywords to collection values.
#+begin_src clojure
(s/conform number? 1968)
;; => 1968
(s/conform s-n-s-n ["Emma" 1815 "Jaws" 1974])
;; => {:s1 "Emma", :n1 1815, :s2 "Jaws", :n2 1974}
#+end_src
** Function specs
Above facilitates a spec matching at critical points in your code
*** Choice1
~:pre~ and ~:post~ keywords inside ~defn~

Let us say we want to ensure the shape of ~:title~ and ~:inventory~ passed to the ~find-by-title~ function:-
#+begin_src clojure
(s/def ::inventory (s/coll-of ::book))
;; => :inventory.core/inventory

(defn find-by-title
  "Search for a book by title, where title is a string and books is a collection of book maps, each of which must have a :title entry"
  [title books]
  {:pre [(s/valid? ::title title)
         (s/valid? ::inventory books)]}
  (some #(if (= (:title %) title) %) books))
;; => #'inventory.core/find-by-title
#+end_src
*** Choice2
Keeps the spec seperate from the ~defn~
#+begin_src clojure
(defn find-by-title [title books]
  (some #(if (= (:title %) title) %) books))
;; => #'inventory.core/find-by-title
#+end_src

Register a spec for the above function using ~fdef~
#+begin_src clojure
(s/fdef find-by-title
  :args (s/cat :title ::title :inventory ::inventory))
;; => inventory.core/find-by-title
#+end_src
Mnemonic to remember ~fdef~ ,   ''Final-specs-def will be registered"

?Unlike ~:pre~ and ~:post~, we need to turn on the above wired up specs
#+begin_src clojure
(require '[clojure.spec.test.alpha :as st])
;; => nil
(st/instrument 'inventory.core/find-by-title)
;; => [inventory.core/find-by-title]
#+end_src

See it in action
#+begin_src clojure
(find-by-title "Emma" ["Emma" "2001" "Jaws"])
;; => Execution error - invalid arguments to inventory.core/find-by-title at (form-init3142513827429707114.clj:253).
;;    "Emma" - failed: map? at: [:inventory] spec: :inventory.core/book
;;    "2001" - failed: map? at: [:inventory] spec: :inventory.core/book
;;    "Jaws" - failed: map? at: [:inventory] spec: :inventory.core/book
#+end_src

Spec based things can slow things down in production.
Prefer to use it only during development and testing.
** Generative tests that use the specs to auto generate test cases
Specs provides sufficient information to generate a random test case.

Lets say we want to test the below function
#+begin_src clojure
(defn book-blurb [book]
  (str "The best selling book " (:title book) " by " (:author book)))
;; => #'inventory.core/book-blurb
#+end_src

Lets wire up a test using /choice2/
#+begin_src clojure
(s/fdef book-blurb
  :args (s/cat :book ::book))
;; => inventory.core/book-blurb
#+end_src

=clojure.spec.test.alpha/check=
will generate 1000 random testcases and run them
#+begin_src clojure :results output
(require '[clojure.spec.test.alpha :as st])
;; => nil
(st/check 'inventory.core/book-blurb)
;; => ({:spec #object[clojure.spec.alpha$fspec_impl$reify__2518 0x56f46dc8 "clojure.spec.alpha$fspec_impl$reify__2518@56f46dc8"], :clojure.spec.test.check/ret {:result true, :pass? true, :num-tests 1000, :time-elapsed-ms 331, :seed 1724187907172}, :sym inventory.core/book-blurb2})
#+end_src
---------------------------------------------------------------------------------------------------

*** =:ret= check the return value
#+begin_src clojure
(s/fdef book-blurb
  :args (s/cat :book ::book)
  :ret (s/and string? (partial re-find #"The best selling")))
;; => inventory.core/book-blurb
#+end_src

Run it
#+begin_src clojure
(st/check 'inventory.core/book-blurb)
;; => ({:spec #object[clojure.spec.alpha$fspec_impl$reify__2518 0x451e7e8a "clojure.spec.alpha$fspec_impl$reify__2518@451e7e8a"], :clojure.spec.test.check/ret {:result true, :pass? true, :num-tests 1000, :time-elapsed-ms 418, :seed 1724187834720}, :sym inventory.core/book-blurb})
#+end_src
---------------------------------------------------------------------------------------------------
*** The =:fn= key gets handed a map
~{:args <>, :ret <>}~ containing both the function arguments and the return value.
Lets add a predicate for that map
#+begin_src clojure
;;Ensures that the authors name is part of the blurb output
(defn check-args-and-return [{:keys [args ret]}]
  ;;Since we have access to both the ret and the args
  ;;we can write tests that use both the above as parameters

  ;;Eg: check that arg-string is part of the ret-string:-
  (let [author (-> args :book :author)]
    (not (neg? (.indexOf ret author))))
  )
;; => #'inventory.core/check-args-and-return

(s/fdef book-blurb
  :args (s/cat :book ::book)
  :ret (s/and string? (partial re-find #"The best selling"))
  :fn check-args-and-return)
;; => inventory.core/book-blurb
#+end_src

Run it
#+begin_src clojure
(st/check 'inventory.core/book-blurb)
;; => ({:spec #object[clojure.spec.alpha$fspec_impl$reify__2518 0x1c8bd1cd "clojure.spec.alpha$fspec_impl$reify__2518@1c8bd1cd"], :clojure.spec.test.check/ret {:result true, :pass? true, :num-tests 1000, :time-elapsed-ms 364, :seed 1724188840826}, :sym inventory.core/book-blurb})
#+end_src
** Staying out of trouble
If your architecture consists of multiple JVM, ensure to register your specs in each of them.
** In the wild
=ring-spec= contains specs for Ring web applicaiton

=clojure.specs.alpha= contains specs for Clojure itself
~s/?~ makes the next part of the spec optional.

* Part III ---------------------------------------------------------------------------------------------------
:PROPERTIES:
:UNNUMBERED: t
:END:

* Interoperating with Java

* File Settings
:PROPERTIES:
:UNNUMBERED: t
:END:
It is important to ensure that the ~local variables~ are defined near the end of a file.
Specifically, emacs loads ~local variables~ by reading /only/ the last 3000 characters of the file being read.

# Local Variables:
# org-num-max-level: 1
# eval: (progn (org-num-mode -1) (org-num-mode +1))
# eval: (setq org-startup-with-inline-images 'inlineimages)
# eval: (auto-revert-mode -1)
# End:
